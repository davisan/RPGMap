<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web Mapping Studio v6.0 (Separated Controls)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        #glCanvas { position: absolute; top:0; left:0; z-index: 1; display: block; }
        #uiCanvas { position: absolute; top:0; left:0; z-index: 2; display: block; pointer-events: none; }

        /* Interface */
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(18, 18, 18, 0.95); color: #e0e0e0;
            padding: 15px; border-radius: 8px; width: 280px;
            border: 1px solid #333; box-shadow: 0 4px 25px rgba(0,0,0,0.9);
            transition: opacity 0.3s, transform 0.3s;
            max-height: 90vh; overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        .ui-hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }

        h2 { margin: 0 0 10px 0; font-size: 15px; text-transform: uppercase; color: #00ffcc; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 8px; }
        h3 { font-size: 11px; margin: 12px 0 5px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; font-weight: bold;}
        
        .btn-group { display: flex; gap: 5px; margin-bottom: 5px; }
        
        button, select, input[type="text"] {
            width: 100%; margin-bottom: 6px; padding: 10px; box-sizing: border-box;
            background: #2a2a2a; border: 1px solid #444; color: #ddd;
            border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;
        }
        button:hover { background: #3a3a3a; border-color: #666; color: #fff; }
        button:active { transform: scale(0.98); }

        .btn-primary { background: #005f73; border-color: #0a9396; }
        .btn-primary:hover { background: #0a9396; }
        .btn-danger { background: #602020; border-color: #803030; }
        .btn-save { background: #204020; border-color: #306030; }
        
        .playback-controls {
            display: flex; gap: 2px; background: #000; padding: 4px; border-radius: 4px; border: 1px solid #333; margin-bottom: 10px;
        }
        .playback-controls button {
            background: transparent; border: none; font-size: 18px; margin: 0; padding: 5px 0;
        }
        .playback-controls button:hover { background: #222; color: #00ffcc; }

        input[type="color"] { width: 100%; height: 35px; border: none; padding: 0; background: none; cursor: pointer; }
        #fileInput, #jsonInput { display: none; }
        label { font-size: 11px; color: #aaa; display: block; margin-bottom: 3px; }
        
        #toast {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: #333; color: #fff; padding: 10px 25px; border-radius: 30px;
            font-size: 13px; opacity: 0; transition: opacity 0.5s; pointer-events: none; z-index: 200;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="glCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
    </div>

    <div id="toast">A√ß√£o Realizada</div>

    <div id="controls">
        <h2>Mapping Studio <span style="font-size:10px; color:#666; float:right; margin-top:3px;">v6.0</span></h2>
        
        <h3>Projeto</h3>
        <div class="btn-group">
            <button onclick="exportToFile()" class="btn-save" title="Salvar JSON">üíæ Salvar</button>
            <button onclick="document.getElementById('jsonInput').click()" title="Carregar JSON">üìÇ Abrir</button>
            <input type="file" id="jsonInput" accept=".json" onchange="importFromFile(this)">
        </div>
        <button onclick="clearAll()" class="btn-danger" style="padding: 5px; font-size:10px;">Limpar Projeto</button>

        <h3>Maestro (Sincronia)</h3>
        <div class="playback-controls">
            <button onclick="globalAction('play')" title="Play Todos">‚ñ∂</button>
            <button onclick="globalAction('pause')" title="Pause Todos">‚è∏</button>
            <button onclick="globalAction('reset')" title="Reiniciar Todos">‚èÆ</button>
        </div>

        <h3>Visualiza√ß√£o</h3>
        <div class="btn-group">
            <button onclick="toggleFullscreen()" title="Tecla F">‚õ∂ Tela Cheia (F)</button>
            <button onclick="toggleUI()" title="Tecla H">üëÅ Ocultar UI (H)</button>
        </div>
        
        <h3>Cor de Fundo</h3>
        <input type="color" id="bgPicker" value="#000000" oninput="updateBgColor()" style="margin-bottom:10px;">

        <button onclick="addSurface()" class="btn-primary" style="font-weight:bold; margin-top:5px;">+ Nova Tela</button>

        <div id="edit-panel" style="display:none; margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
            <h3 style="color: #00ffcc; margin-top:0;">Editar Sele√ß√£o <span id="sel-id" style="float:right; opacity:0.5">#0</span></h3>
            
            <div class="btn-group">
                <button onclick="moveLayer(-1)">‚ñº Tr√°s</button>
                <button onclick="moveLayer(1)">‚ñ≤ Frente</button>
            </div>

            <label>Conte√∫do:</label>
            <select id="contentType" onchange="updateSurfaceType()">
                <option value="color">Cor S√≥lida</option>
                <option value="image">Imagem</option>
                <option value="video">V√≠deo</option>
            </select>

            <div id="opt-color" class="opts">
                <label>Cor:</label>
                <input type="color" id="surfColorPicker" oninput="updateSurfColor()" value="#00ffcc">
            </div>

            <div id="opt-media" class="opts" style="display:none;">
                <button onclick="document.getElementById('fileInput').click()">üìÅ Escolher Arquivo</button>
                <input type="text" id="urlInput" placeholder="Ou cole URL..." onchange="updateUrl(this.value)">
                <input type="file" id="fileInput" accept="image/*,video/*" onchange="handleFileUpload(this)">
                <div id="media-warning" style="font-size: 10px; color: #ff8888; margin-top:4px; display:none; line-height: 1.2;">
                    ‚ö†Ô∏è Recarregar arquivo se atualizar a p√°gina.
                </div>
            </div>
            
            <button onclick="deleteSurface()" class="btn-danger" style="margin-top:10px;">Remover Tela</button>
        </div>

        <div id="no-selection" style="color:#666; font-size: 11px; text-align: center; padding: 20px 0;">
            Selecione um ret√¢ngulo.
        </div>
    </div>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform mat4 u_matrix;
    varying vec2 v_texCoord;
    void main() {
        vec4 position = u_matrix * vec4(a_position, 0.0, 1.0);
        gl_Position = vec4(position.xy / position.w, 0.0, 1.0);
        v_texCoord = a_texCoord;
    }
</script>
<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_texture;
    uniform vec4 u_color;
    uniform bool u_useTexture;
    varying vec2 v_texCoord;
    void main() {
        if (u_useTexture) {
            gl_FragColor = texture2D(u_texture, v_texCoord);
        } else {
            gl_FragColor = u_color;
        }
    }
</script>

<script>
    // --- 1. Inicializa√ß√£o ---
    const glCanvas = document.getElementById('glCanvas');
    const uiCanvas = document.getElementById('uiCanvas');
    const gl = glCanvas.getContext('webgl', { alpha: false, preserveDrawingBuffer: true });
    const ctx = uiCanvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const controlsDiv = document.getElementById('controls');

    if (!gl) alert("WebGL n√£o suportado.");

    let lastWidth = window.innerWidth;
    let lastHeight = window.innerHeight;

    // --- 2. Resize El√°stico ---
    function resize() {
        const pixelRatio = window.devicePixelRatio || 1;
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;

        if (newWidth !== lastWidth || newHeight !== lastHeight) {
            if (lastWidth > 0 && lastHeight > 0) {
                const scaleX = newWidth / lastWidth;
                const scaleY = newHeight / lastHeight;
                surfaces.forEach(surf => {
                    surf.points.forEach(p => { p.x *= scaleX; p.y *= scaleY; });
                });
            }
            lastWidth = newWidth;
            lastHeight = newHeight;
        }

        glCanvas.width  = newWidth * pixelRatio;
        glCanvas.height = newHeight * pixelRatio;
        uiCanvas.width  = newWidth * pixelRatio;
        uiCanvas.height = newHeight * pixelRatio;

        glCanvas.style.width = newWidth + "px";
        glCanvas.style.height = newHeight + "px";
        uiCanvas.style.width = newWidth + "px";
        uiCanvas.style.height = newHeight + "px";

        ctx.resetTransform();
        ctx.scale(pixelRatio, pixelRatio);
        gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    }

    window.addEventListener('resize', resize);
    // Listener espec√≠fico para quando entra/sai de fullscreen
    document.addEventListener('fullscreenchange', () => {
        resize();
        setTimeout(resize, 100);
        setTimeout(resize, 300);
    });

    // --- 3. Estado ---
    let surfaces = [];
    let selectedSurfaceIndex = -1;
    let draggingPoint = null;
    let bgColor = [0, 0, 0, 1];
    let uiVisible = true;
    let autoSaveTimeout = null;

    class Surface {
        constructor(x, y, w, h) {
            this.points = [{x,y}, {x:x+w, y}, {x:x+w, y:y+h}, {x, y:y+h}];
            this.type = 'color';
            this.glolor = [0.0, 1.0, 0.8, 1.0];
            this.hexColor = "#00ffcc";
            this.mediaElement = null;
            this.glTexture = null;
            this.isTextureReady = false;
            this.sourceUrl = null;
            this.isLocalFile = false;
        }
    }

    // --- 4. WebGL Setup ---
    function createShader(gl, type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) return null;
        return s;
    }
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text));
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);

    const locs = {
        pos: gl.getAttribLocation(program, "a_position"),
        tex: gl.getAttribLocation(program, "a_texCoord"),
        mat: gl.getUniformLocation(program, "u_matrix"),
        uTex: gl.getUniformLocation(program, "u_texture"),
        col: gl.getUniformLocation(program, "u_color"),
        useT: gl.getUniformLocation(program, "u_useTexture")
    };

    const placeholderTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, placeholderTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([50,50,50,255]));

    // --- 5. Matem√°tica ---
    function computeHomographyMatrix(points, width, height) {
        const p = points.map(pt => ({ x: (pt.x/width)*2-1, y: 1-(pt.y/height)*2 }));
        const s = [{x:0,y:0}, {x:1,y:0}, {x:1,y:1}, {x:0,y:1}];
        const a = [], b = [];
        for(let i=0; i<4; ++i) {
            a.push([s[i].x, s[i].y, 1, 0, 0, 0, -s[i].x*p[i].x, -s[i].y*p[i].x]);
            a.push([0, 0, 0, s[i].x, s[i].y, 1, -s[i].x*p[i].y, -s[i].y*p[i].y]);
            b.push(p[i].x); b.push(p[i].y);
        }
        const n=8;
        for (let i=0; i<n; ++i) {
            let max=Math.abs(a[i][i]), row=i;
            for(let k=i+1; k<n; ++k) if(Math.abs(a[k][i])>max){max=Math.abs(a[k][i]); row=k;}
            for(let k=i; k<n; ++k) {const t=a[row][k]; a[row][k]=a[i][k]; a[i][k]=t;}
            const t=b[row]; b[row]=b[i]; b[i]=t;
            for(let k=i+1; k<n; ++k) {
                const c=-a[k][i]/a[i][i];
                for(let j=i; j<n; ++j) a[k][j]+=c*a[i][j];
                b[k]+=c*b[i];
            }
        }
        const x=new Array(n).fill(0);
        for(let i=n-1; i>=0; --i) {
            let sum=0; for(let j=i+1; j<n; ++j) sum+=a[i][j]*x[j];
            x[i]=(b[i]-sum)/a[i][i];
        }
        return [x[0], x[3], 0, x[6], x[1], x[4], 0, x[7], 0, 0, 1, 0, x[2], x[5], 0, 1];
    }

    // --- 6. Render ---
    function renderWebGL() {
        gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(locs.pos, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locs.pos);
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.vertexAttribPointer(locs.tex, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locs.tex);

        surfaces.forEach(surf => {
            const m = computeHomographyMatrix(surf.points, window.innerWidth, window.innerHeight);
            gl.uniformMatrix4fv(locs.mat, false, m);

            if (surf.type === 'color') {
                gl.uniform1i(locs.useT, 0);
                gl.uniform4fv(locs.col, surf.glolor);
            } else {
                gl.uniform1i(locs.useT, 1);
                gl.activeTexture(gl.TEXTURE0);
                if (surf.type === 'video' && surf.mediaElement && surf.isTextureReady) {
                     gl.bindTexture(gl.TEXTURE_2D, surf.glTexture);
                     try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, surf.mediaElement); } catch(e) {}
                } else if (surf.glTexture && surf.isTextureReady) {
                     gl.bindTexture(gl.TEXTURE_2D, surf.glTexture);
                } else {
                     gl.bindTexture(gl.TEXTURE_2D, placeholderTex);
                }
                gl.uniform1i(locs.uTex, 0);
            }
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        });
    }

    function renderUI() {
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        if (!uiVisible) return;

        surfaces.forEach((surf, index) => {
            const isSelected = index === selectedSurfaceIndex;
            ctx.beginPath();
            ctx.moveTo(surf.points[0].x, surf.points[0].y);
            surf.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();

            if (isSelected) {
                ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#fff';
                surf.points.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                });
                const cx = (surf.points[0].x + surf.points[2].x)/2;
                const cy = (surf.points[0].y + surf.points[2].y)/2;
                ctx.fillStyle = "#00ffcc"; ctx.font="bold 14px sans-serif"; 
                ctx.fillText("#"+index, cx-8, cy);

                if(surf.isLocalFile && !surf.isTextureReady) {
                    ctx.fillStyle = "#ff5555"; ctx.font="12px sans-serif";
                    ctx.fillText("‚ö†Ô∏è Recarregar", cx-40, cy+20);
                }
            } else {
                ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1; ctx.stroke();
            }
        });
    }

    function animate() {
        renderWebGL();
        renderUI();
        requestAnimationFrame(animate);
    }
    resize();
    animate();

    // --- 7. Intera√ß√£o ---
    function getPointerPos(e) {
        if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        return { x: e.clientX, y: e.clientY };
    }

    function handlePointerDown(e) {
        if (!uiVisible) return;
        if (e.cancelable && e.touches) e.preventDefault();
        const mp = getPointerPos(e);
        let clickedCorner = false;

        if (selectedSurfaceIndex !== -1) {
            surfaces[selectedSurfaceIndex].points.forEach((p, idx) => {
                if (Math.hypot(p.x - mp.x, p.y - mp.y) < 25) { 
                    draggingPoint = { surfIdx: selectedSurfaceIndex, ptIdx: idx }; 
                    clickedCorner = true; 
                }
            });
        }
        if (!clickedCorner) {
            let found = -1;
            for (let i = surfaces.length - 1; i >= 0; i--) {
                const vs = surfaces[i].points;
                let inside = false;
                for (let j = 0, k = vs.length - 1; j < vs.length; k = j++) {
                    if (((vs[j].y > mp.y) != (vs[k].y > mp.y)) && 
                        (mp.x < (vs[k].x - vs[j].x) * (mp.y - vs[j].y) / (vs[k].y - vs[j].y) + vs[j].x)) inside = !inside;
                }
                if(inside) { found = i; break; }
            }
            selectSurface(found);
        }
    }

    function handlePointerMove(e) {
        if (!uiVisible) return;
        if (e.touches) e.preventDefault();
        const mp = getPointerPos(e);
        if (draggingPoint) {
            const p = surfaces[draggingPoint.surfIdx].points[draggingPoint.ptIdx];
            p.x = mp.x; p.y = mp.y;
        } else {
            let hovering = false;
            if(selectedSurfaceIndex > -1) surfaces[selectedSurfaceIndex].points.forEach(p=>{if(Math.hypot(p.x-mp.x, p.y-mp.y)<25) hovering=true;});
            container.style.cursor = hovering ? 'move' : 'default';
        }
    }

    function handlePointerUp() {
        if (draggingPoint) triggerAutoSave();
        draggingPoint = null;
    }

    container.addEventListener('mousedown', handlePointerDown);
    container.addEventListener('mousemove', handlePointerMove);
    window.addEventListener('mouseup', handlePointerUp);
    container.addEventListener('touchstart', handlePointerDown, { passive: false });
    container.addEventListener('touchmove', handlePointerMove, { passive: false });
    window.addEventListener('touchend', handlePointerUp);

    // --- 8. Controles Separados (Fullscreen vs UI) ---

    // Alternar APENAS a Interface
    function toggleUI(show) {
        // Se show for indefinido, inverte o estado atual
        uiVisible = (show !== undefined) ? show : !uiVisible;
        
        if (uiVisible) {
            controlsDiv.classList.remove('ui-hidden');
            uiCanvas.style.pointerEvents = 'auto';
        } else {
            controlsDiv.classList.add('ui-hidden');
            uiCanvas.style.pointerEvents = 'none';
            selectSurface(-1);
        }
    }

    // Alternar APENAS Tela Cheia
    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(e => console.log(e));
        } else {
            document.exitFullscreen();
        }
    }

    // Atalhos de Teclado Atualizados
    window.addEventListener('keydown', (e) => {
        // Tecla H: Esconde/Mostra Interface
        if (e.key.toLowerCase() === 'h') toggleUI();
        
        // Tecla F: Entra/Sai Tela Cheia
        if (e.key.toLowerCase() === 'f') toggleFullscreen();
        
        // Tecla ESC: O padr√£o do navegador √© sair do fullscreen. 
        // N√£o precisamos fazer nada aqui, o evento 'fullscreenchange' j√° lida com o resize.
        // Se quiser que ESC tamb√©m mostre a UI (caso esteja escondida), descomente abaixo:
        // if (e.key === 'Escape') toggleUI(true);

        if (e.code === 'Space') {
            const v = surfaces.find(s => s.type === 'video' && s.mediaElement);
            if(v) (v.mediaElement.paused) ? globalAction('play') : globalAction('pause');
        }
    });

    // --- 9. UI Helpers ---

    function addSurface() {
        const w = 300, h = 200;
        surfaces.push(new Surface((window.innerWidth-w)/2, (window.innerHeight-h)/2, w, h));
        selectSurface(surfaces.length - 1);
        triggerAutoSave();
    }
    
    function selectSurface(i) {
        selectedSurfaceIndex = i;
        const panel = document.getElementById('edit-panel');
        const noSel = document.getElementById('no-selection');
        if (i === -1) { panel.style.display='none'; noSel.style.display='block'; return;}
        
        panel.style.display='block'; noSel.style.display='none';
        document.getElementById('sel-id').innerText = "#"+i;
        
        const s = surfaces[i];
        document.getElementById('contentType').value = s.type;
        document.getElementById('surfColorPicker').value = s.hexColor;
        document.getElementById('urlInput').value = (s.sourceUrl && !s.isLocalFile) ? s.sourceUrl : '';
        const warning = document.getElementById('media-warning');
        warning.style.display = (s.type !== 'color' && s.isLocalFile) ? 'block' : 'none';
        
        updateUIForType(s.type);
    }

    function deleteSurface() {
        if(selectedSurfaceIndex===-1)return;
        const s = surfaces[selectedSurfaceIndex];
        if(s.glTexture) gl.deleteTexture(s.glTexture);
        surfaces.splice(selectedSurfaceIndex,1);
        selectSurface(-1);
        triggerAutoSave();
    }

    function moveLayer(dir) {
        if(selectedSurfaceIndex===-1)return;
        const nIdx = selectedSurfaceIndex + dir;
        if(nIdx < 0 || nIdx >= surfaces.length) return;
        [surfaces[selectedSurfaceIndex], surfaces[nIdx]] = [surfaces[nIdx], surfaces[selectedSurfaceIndex]];
        selectSurface(nIdx);
        triggerAutoSave();
    }

    function updateUIForType(t) {
        document.getElementById('opt-color').style.display = t === 'color' ? 'block' : 'none';
        document.getElementById('opt-media').style.display = (t === 'image' || t === 'video') ? 'block' : 'none';
    }
    
    function updateSurfaceType() {
        if(selectedSurfaceIndex===-1)return;
        const t = document.getElementById('contentType').value;
        surfaces[selectedSurfaceIndex].type = t;
        updateUIForType(t);
        selectSurface(selectedSurfaceIndex); 
        triggerAutoSave();
    }

    function updateBgColor() {
        const h = document.getElementById('bgPicker').value;
        bgColor = hexToRgbGL(h);
        triggerAutoSave();
    }
    
    function updateSurfColor() {
        if(selectedSurfaceIndex===-1)return;
        const h = document.getElementById('surfColorPicker').value;
        surfaces[selectedSurfaceIndex].hexColor = h;
        surfaces[selectedSurfaceIndex].glolor = hexToRgbGL(h);
        triggerAutoSave();
    }

    function handleFileUpload(input) {
        if(selectedSurfaceIndex===-1 || !input.files[0]) return;
        const f = input.files[0];
        const u = URL.createObjectURL(f);
        const t = f.type.startsWith('video') ? 'video' : 'image';
        const s = surfaces[selectedSurfaceIndex];
        s.isLocalFile = true; s.sourceUrl = null;
        applyMediaToSurface(s, u, t);
        selectSurface(selectedSurfaceIndex);
        triggerAutoSave();
    }

    function updateUrl(u) {
        if(selectedSurfaceIndex===-1 || !u) return;
        const s = surfaces[selectedSurfaceIndex];
        const isV = u.match(/\.(mp4|webm|ogg|mov)$/i);
        s.isLocalFile = false; s.sourceUrl = u;
        applyMediaToSurface(s, u, isV ? 'video' : 'image');
        triggerAutoSave();
    }

    function applyMediaToSurface(s, url, type) {
        s.type = type; s.isTextureReady = false;
        if(s.glTexture) gl.deleteTexture(s.glTexture);
        s.glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, s.glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        
        if (type === 'video') {
            const v = document.createElement('video');
            v.crossOrigin = "anonymous";
            v.src = url; v.loop = true; v.muted = true; v.autoplay = false; v.playsInline = true;
            v.addEventListener('canplay', () => { s.isTextureReady = true; });
            s.mediaElement = v;
        } else {
            const i = new Image();
            i.crossOrigin = "anonymous";
            i.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, s.glTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);
                s.isTextureReady = true;
            };
            i.src = url;
            s.mediaElement = i;
        }
    }

    function globalAction(action) {
        surfaces.forEach(surf => {
            if (surf.type === 'video' && surf.mediaElement) {
                if(action === 'play') surf.mediaElement.play().catch(e=>{});
                if(action === 'pause') surf.mediaElement.pause();
                if(action === 'reset') { surf.mediaElement.currentTime = 0; surf.mediaElement.pause(); }
            }
        });
        showToast("A√ß√£o Global: " + action.toUpperCase());
    }

    // --- 10. Persist√™ncia ---
    function getSceneData() {
        return {
            bg: document.getElementById('bgPicker').value,
            surfaces: surfaces.map(s => ({
                points: s.points,
                type: s.type,
                hexColor: s.hexColor,
                sourceUrl: s.sourceUrl,
                isLocalFile: s.isLocalFile
            }))
        };
    }

    function loadSceneData(data) {
        if(!data) return;
        if(data.bg) { document.getElementById('bgPicker').value = data.bg; updateBgColor(); }
        if(data.surfaces) {
            surfaces.forEach(s => { if(s.glTexture) gl.deleteTexture(s.glTexture); });
            surfaces = [];
            data.surfaces.forEach(sd => {
                const surf = new Surface(0,0,100,100);
                surf.points = sd.points;
                surf.type = sd.type;
                surf.hexColor = sd.hexColor;
                surf.glolor = hexToRgbGL(sd.hexColor);
                surf.isLocalFile = sd.isLocalFile;
                surf.sourceUrl = sd.sourceUrl;
                if (surf.type !== 'color' && !surf.isLocalFile && surf.sourceUrl) {
                    applyMediaToSurface(surf, surf.sourceUrl, surf.type);
                }
                surfaces.push(surf);
            });
            selectSurface(-1);
        }
    }

    function triggerAutoSave() {
        clearTimeout(autoSaveTimeout);
        autoSaveTimeout = setTimeout(() => {
            localStorage.setItem('mapping_studio_autosave', JSON.stringify(getSceneData()));
        }, 500);
    }

    window.addEventListener('load', () => {
        const saved = localStorage.getItem('mapping_studio_autosave');
        if(saved) {
            try { loadSceneData(JSON.parse(saved)); showToast("Sess√£o Restaurada"); } 
            catch(e) { console.error(e); }
        }
    });

    function exportToFile() {
        const blob = new Blob([JSON.stringify(getSceneData(), null, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = "mapping_project.json";
        a.click(); URL.revokeObjectURL(url);
        showToast("Projeto Exportado");
    }

    function importFromFile(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                loadSceneData(JSON.parse(e.target.result));
                triggerAutoSave();
                showToast("Projeto Importado");
            } catch(err) { alert("Arquivo inv√°lido"); }
        };
        reader.readAsText(file);
        input.value = '';
    }
    
    function clearAll() {
        if(confirm("Apagar todas as telas?")) {
            surfaces = []; selectSurface(-1); triggerAutoSave(); showToast("Tudo Limpo");
        }
    }

    function hexToRgbGL(hex) {
        const bi = parseInt(hex.slice(1), 16);
        return [((bi>>16)&255)/255, ((bi>>8)&255)/255, (bi&255)/255, 1.0];
    }
    function showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity = 1;
        setTimeout(() => t.style.opacity = 0, 2000);
    }
</script>
</body>
</html>