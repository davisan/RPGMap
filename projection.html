<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DV Projection Mapping 0.1</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        #glCanvas { position: absolute; top:0; left:0; z-index: 1; display: block; }
        #uiCanvas { position: absolute; top:0; left:0; z-index: 2; display: block; pointer-events: none; }

        /* Interface - Agora com posi√ß√£o inicial din√¢mica via JS, mas padr√£o aqui */
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(18, 18, 18, 0.95); color: #e0e0e0;
            padding: 15px; border-radius: 8px; width: 280px;
            border: 1px solid #333; box-shadow: 0 4px 25px rgba(0,0,0,0.9);
            transition: opacity 0.3s, transform 0.3s;
            max-height: 90vh; overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        .ui-hidden { opacity: 0; pointer-events: none; }

        /* HEADER ARRAST√ÅVEL */
        #drag-handle {
            margin: -15px -15px 10px -15px; /* Compensa o padding do pai */
            padding: 15px 15px 8px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid #333;
            cursor: move; /* Cursor de movimento */
            user-select: none;
            border-radius: 8px 8px 0 0;
        }
        #drag-handle h2 { 
            margin: 0; font-size: 15px; text-transform: uppercase; color: #00ffcc; letter-spacing: 1px; pointer-events: none;
        }

        h3 { font-size: 11px; margin: 12px 0 5px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; font-weight: bold;}
        
        .btn-group { display: flex; gap: 5px; margin-bottom: 5px; }
        
        button, select, input[type="text"] {
            width: 100%; margin-bottom: 6px; padding: 10px; box-sizing: border-box;
            background: #2a2a2a; border: 1px solid #444; color: #ddd;
            border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;
        }
        button:hover { background: #3a3a3a; border-color: #666; color: #fff; }
        button:active { transform: scale(0.98); }

        .btn-primary { background: #005f73; border-color: #0a9396; }
        .btn-primary:hover { background: #0a9396; }
        .btn-danger { background: #602020; border-color: #803030; }
        .btn-save { background: #204020; border-color: #306030; }
        
        .playback-controls {
            display: flex; gap: 2px; background: #000; padding: 4px; border-radius: 4px; border: 1px solid #333; margin-bottom: 10px;
        }
        .playback-controls button {
            background: transparent; border: none; font-size: 18px; margin: 0; padding: 5px 0;
        }
        .playback-controls button:hover { background: #222; color: #00ffcc; }

        input[type="color"] { width: 100%; height: 35px; border: none; padding: 0; background: none; cursor: pointer; }
        #fileInput, #jsonInput { display: none; }
        label { font-size: 11px; color: #aaa; display: block; margin-bottom: 3px; }
        
        #toast {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: #333; color: #fff; padding: 10px 25px; border-radius: 30px;
            font-size: 13px; opacity: 0; transition: opacity 0.5s; pointer-events: none; z-index: 200;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="glCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
    </div>

    <div id="toast">A√ß√£o Realizada</div>

    <div id="controls">
        <div id="drag-handle">
            <h2>DV Projection Mapping <span style="font-size:10px; color:#666; float:right; margin-top:3px;">v0.1</span></h2>
        </div>
        
        <h3>Projeto</h3>
        <div class="btn-group">
            <button onclick="exportToFile()" class="btn-save" title="Salvar JSON">üíæ Salvar</button>
            <button onclick="document.getElementById('jsonInput').click()" title="Carregar JSON">üìÇ Abrir</button>
            <input type="file" id="jsonInput" accept=".json" onchange="importFromFile(this)">
        </div>
        <button onclick="clearAll()" class="btn-danger" style="padding: 5px; font-size:10px;">Limpar Projeto</button>

        <h3>Maestro (Sincronia)</h3>
        <div class="playback-controls">
            <button onclick="globalAction('play')" title="Play Todos">‚ñ∂</button>
            <button onclick="globalAction('pause')" title="Pause Todos">‚è∏</button>
            <button onclick="globalAction('reset')" title="Reiniciar Todos">‚èÆ</button>
        </div>

        <h3>Visualiza√ß√£o</h3>
        <div class="btn-group">
            <button onclick="toggleFullscreen()" title="Tecla F">‚õ∂ Tela Cheia (F)</button>
            <button onclick="toggleUI()" title="Tecla H">üëÅ Ocultar UI (H)</button>
        </div>
        
        <h3>Cor de Fundo</h3>
        <input type="color" id="bgPicker" value="#000000" oninput="updateBgColor()" style="margin-bottom:10px;">

        <button onclick="addSurface()" class="btn-primary" style="font-weight:bold; margin-top:5px;">+ Nova Tela</button>

        <div id="edit-panel" style="display:none; margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
            <h3 style="color: #00ffcc; margin-top:0;">Editar Sele√ß√£o <span id="sel-id" style="float:right; opacity:0.5">#0</span></h3>
            
            <div class="btn-group">
                <button onclick="moveLayer(-1)">‚ñº Tr√°s</button>
                <button onclick="moveLayer(1)">‚ñ≤ Frente</button>
            </div>

            <label>Conte√∫do:</label>
            <select id="contentType" onchange="updateSurfaceType()">
                <option value="color">Cor S√≥lida</option>
                <option value="image">Imagem</option>
                <option value="video">V√≠deo</option>
            </select>

            <div id="opt-color" class="opts">
                <label>Cor:</label>
                <input type="color" id="surfColorPicker" oninput="updateSurfColor()" value="#00ffcc">
            </div>

            <div id="opt-media" class="opts" style="display:none;">
                <button onclick="document.getElementById('fileInput').click()">üìÅ Escolher Arquivo</button>
                <input type="text" id="urlInput" placeholder="Ou cole URL..." onchange="updateUrl(this.value)">
                <input type="file" id="fileInput" accept="image/*,video/*" onchange="handleFileUpload(this)">
                <div id="media-warning" style="font-size: 10px; color: #ff8888; margin-top:4px; display:none; line-height: 1.2;">
                    ‚ö†Ô∏è Recarregar arquivo se atualizar a p√°gina.
                </div>
            </div>
            
            <button onclick="deleteSurface()" class="btn-danger" style="margin-top:10px;">Remover Tela</button>
        </div>

        <div id="no-selection" style="color:#666; font-size: 11px; text-align: center; padding: 20px 0;">
            Selecione um ret√¢ngulo.
        </div>
    </div>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position; attribute vec2 a_texCoord; uniform mat4 u_matrix; varying vec2 v_texCoord;
    void main() { vec4 p=u_matrix*vec4(a_position,0.0,1.0); gl_Position=vec4(p.xy/p.w,0.0,1.0); v_texCoord=a_texCoord; }
</script>
<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float; uniform sampler2D u_texture; uniform vec4 u_color; uniform bool u_useTexture; varying vec2 v_texCoord;
    void main() { if(u_useTexture) gl_FragColor=texture2D(u_texture,v_texCoord); else gl_FragColor=u_color; }
</script>

<script>
    // --- 1. Inicializa√ß√£o ---
    const glCanvas = document.getElementById('glCanvas');
    const uiCanvas = document.getElementById('uiCanvas');
    const gl = glCanvas.getContext('webgl', { alpha: false, preserveDrawingBuffer: true });
    const ctx = uiCanvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const controlsDiv = document.getElementById('controls');

    if (!gl) alert("WebGL n√£o suportado.");

    let lastWidth = window.innerWidth;
    let lastHeight = window.innerHeight;

    function resize() {
        const pr = window.devicePixelRatio || 1;
        const nw = window.innerWidth, nh = window.innerHeight;
        if (nw !== lastWidth || nh !== lastHeight) {
            if (lastWidth > 0 && lastHeight > 0) {
                const sx = nw / lastWidth, sy = nh / lastHeight;
                surfaces.forEach(s => s.points.forEach(p => { p.x *= sx; p.y *= sy; }));
            }
            lastWidth = nw; lastHeight = nh;
        }
        glCanvas.width = nw * pr; glCanvas.height = nh * pr;
        uiCanvas.width = nw * pr; uiCanvas.height = nh * pr;
        glCanvas.style.width = nw + "px"; glCanvas.style.height = nh + "px";
        uiCanvas.style.width = nw + "px"; uiCanvas.style.height = nh + "px";
        ctx.resetTransform(); ctx.scale(pr, pr);
        gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    }
    window.addEventListener('resize', resize);
    document.addEventListener('fullscreenchange', () => { resize(); setTimeout(resize, 100); setTimeout(resize, 300); });

    // --- 2. L√≥gica de UI Arrast√°vel (NOVO) ---
    (function initDraggableMenu() {
        const handle = document.getElementById('drag-handle');
        const menu = document.getElementById('controls');
        let isDraggingMenu = false;
        let startX, startY, initialLeft, initialTop;

        // Recupera posi√ß√£o salva
        const savedPos = localStorage.getItem('mapping_menu_pos');
        if (savedPos) {
            const pos = JSON.parse(savedPos);
            menu.style.left = pos.left;
            menu.style.top = pos.top;
        }

        function startDrag(e) {
            // Evita drag se clicar em bot√µes dentro do header (se houver)
            if (e.target.tagName === 'BUTTON') return;
            
            isDraggingMenu = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            startX = clientX;
            startY = clientY;
            
            const rect = menu.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;
            
            handle.style.cursor = 'grabbing';
            if(e.type === 'touchstart') e.preventDefault();
        }

        function doDrag(e) {
            if (!isDraggingMenu) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const dx = clientX - startX;
            const dy = clientY - startY;
            
            menu.style.left = `${initialLeft + dx}px`;
            menu.style.top = `${initialTop + dy}px`;
            if(e.type === 'touchmove') e.preventDefault();
        }

        function stopDrag() {
            if (isDraggingMenu) {
                isDraggingMenu = false;
                handle.style.cursor = 'move';
                // Salva posi√ß√£o
                localStorage.setItem('mapping_menu_pos', JSON.stringify({
                    left: menu.style.left,
                    top: menu.style.top
                }));
            }
        }

        handle.addEventListener('mousedown', startDrag);
        window.addEventListener('mousemove', doDrag);
        window.addEventListener('mouseup', stopDrag);
        
        // Touch support para menu
        handle.addEventListener('touchstart', startDrag, {passive: false});
        window.addEventListener('touchmove', doDrag, {passive: false});
        window.addEventListener('touchend', stopDrag);
    })();


    // --- 3. Estado & Classes ---
    let surfaces = [];
    let selectedSurfaceIndex = -1;
    let draggingPoint = null;
    let bgColor = [0, 0, 0, 1];
    let uiVisible = true;
    let autoSaveTimeout = null;

    class Surface {
        constructor(x, y, w, h) {
            this.points = [{x,y}, {x:x+w, y}, {x:x+w, y:y+h}, {x, y:y+h}];
            this.type = 'color';
            this.glolor = [0.0, 1.0, 0.8, 1.0];
            this.hexColor = "#00ffcc";
            this.mediaElement = null;
            this.glTexture = null;
            this.isTextureReady = false;
            this.sourceUrl = null;
            this.isLocalFile = false;
        }
    }

    // --- 4. WebGL Internals ---
    function createShader(gl, type, src) {
        const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s;
    }
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text));
    gl.linkProgram(program); gl.useProgram(program);

    const posBuff = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuff);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
    const texBuff = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, texBuff);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);

    const locs = {
        pos: gl.getAttribLocation(program, "a_position"), tex: gl.getAttribLocation(program, "a_texCoord"),
        mat: gl.getUniformLocation(program, "u_matrix"), uTex: gl.getUniformLocation(program, "u_texture"),
        col: gl.getUniformLocation(program, "u_color"), useT: gl.getUniformLocation(program, "u_useTexture")
    };
    const phTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, phTex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([50,50,50,255]));

    function computeHomography(p, w, h) {
        const pts = p.map(pt => ({ x: (pt.x/w)*2-1, y: 1-(pt.y/h)*2 }));
        const src = [{x:0,y:0}, {x:1,y:0}, {x:1,y:1}, {x:0,y:1}];
        const a=[], b=[];
        for(let i=0; i<4; ++i) {
            a.push([src[i].x, src[i].y, 1, 0, 0, 0, -src[i].x*pts[i].x, -src[i].y*pts[i].x]);
            a.push([0, 0, 0, src[i].x, src[i].y, 1, -src[i].x*pts[i].y, -src[i].y*pts[i].y]);
            b.push(pts[i].x); b.push(pts[i].y);
        }
        // Gauss elimination compacta
        const n=8;
        for(let i=0; i<n; ++i) {
            let max=Math.abs(a[i][i]), row=i;
            for(let k=i+1; k<n; ++k) if(Math.abs(a[k][i])>max){max=Math.abs(a[k][i]); row=k;}
            for(let k=i; k<n; ++k) {const t=a[row][k]; a[row][k]=a[i][k]; a[i][k]=t;}
            const t=b[row]; b[row]=b[i]; b[i]=t;
            for(let k=i+1; k<n; ++k) { const c=-a[k][i]/a[i][i]; for(let j=i; j<n; ++j) a[k][j]+=c*a[i][j]; b[k]+=c*b[i]; }
        }
        const x=new Array(n).fill(0);
        for(let i=n-1; i>=0; --i) { let sum=0; for(let j=i+1; j<n; ++j) sum+=a[i][j]*x[j]; x[i]=(b[i]-sum)/a[i][i]; }
        return [x[0], x[3], 0, x[6], x[1], x[4], 0, x[7], 0, 0, 1, 0, x[2], x[5], 0, 1];
    }

    // --- 5. Render Loop ---
    function render() {
        gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]); gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuff); gl.vertexAttribPointer(locs.pos, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(locs.pos);
        gl.bindBuffer(gl.ARRAY_BUFFER, texBuff); gl.vertexAttribPointer(locs.tex, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(locs.tex);

        surfaces.forEach(s => {
            const m = computeHomography(s.points, window.innerWidth, window.innerHeight);
            gl.uniformMatrix4fv(locs.mat, false, m);
            if (s.type === 'color') {
                gl.uniform1i(locs.useT, 0); gl.uniform4fv(locs.col, s.glolor);
            } else {
                gl.uniform1i(locs.useT, 1); gl.activeTexture(gl.TEXTURE0);
                if (s.type==='video' && s.mediaElement && s.isTextureReady) {
                     gl.bindTexture(gl.TEXTURE_2D, s.glTexture);
                     try { gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,s.mediaElement); } catch(e){}
                } else if(s.glTexture && s.isTextureReady) gl.bindTexture(gl.TEXTURE_2D, s.glTexture);
                else gl.bindTexture(gl.TEXTURE_2D, phTex);
                gl.uniform1i(locs.uTex, 0);
            }
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        });
        
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        if (uiVisible) {
            surfaces.forEach((s, i) => {
                const sel = i === selectedSurfaceIndex;
                ctx.beginPath(); ctx.moveTo(s.points[0].x, s.points[0].y);
                s.points.forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath();
                if (sel) {
                    ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#fff';
                    s.points.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, 6.28); ctx.fill(); ctx.stroke(); });
                    const cx = (s.points[0].x + s.points[2].x)/2, cy = (s.points[0].y + s.points[2].y)/2;
                    ctx.fillStyle = "#00ffcc"; ctx.font="bold 14px sans-serif"; ctx.fillText("#"+i, cx-8, cy);
                    if(s.isLocalFile && !s.isTextureReady) { ctx.fillStyle="#f55"; ctx.font="12px sans-serif"; ctx.fillText("‚ö†Ô∏è Recarregar", cx-40, cy+20); }
                } else { ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1; ctx.stroke(); }
            });
        }
        requestAnimationFrame(render);
    }
    resize(); render();

    // --- 6. Intera√ß√£o Canvas (Drag Pontos) ---
    function getPtr(e) { return e.touches ? {x:e.touches[0].clientX, y:e.touches[0].clientY} : {x:e.clientX, y:e.clientY}; }
    function ptrDown(e) {
        if (!uiVisible) return;
        if (e.cancelable && e.touches) e.preventDefault();
        const p = getPtr(e); let hit = false;
        if (selectedSurfaceIndex !== -1) {
            surfaces[selectedSurfaceIndex].points.forEach((pt, i) => {
                if (Math.hypot(pt.x - p.x, pt.y - p.y) < 25) { draggingPoint = {s:selectedSurfaceIndex, p:i}; hit = true; }
            });
        }
        if (!hit) {
            let f = -1;
            for (let i=surfaces.length-1; i>=0; i--) { // Ray cast simples
                const vs=surfaces[i].points; let ins=false;
                for(let j=0,k=vs.length-1; j<vs.length; k=j++) if(((vs[j].y>p.y)!=(vs[k].y>p.y))&&(p.x<(vs[k].x-vs[j].x)*(p.y-vs[j].y)/(vs[k].y-vs[j].y)+vs[j].x)) ins=!ins;
                if(ins) { f=i; break; }
            }
            selectSurface(f);
        }
    }
    function ptrMove(e) {
        if (!uiVisible) return;
        if (e.touches) e.preventDefault();
        const p = getPtr(e);
        if (draggingPoint) { surfaces[draggingPoint.s].points[draggingPoint.p].x = p.x; surfaces[draggingPoint.s].points[draggingPoint.p].y = p.y; }
        else {
            let h = false;
            if(selectedSurfaceIndex>-1) surfaces[selectedSurfaceIndex].points.forEach(pt=>{if(Math.hypot(pt.x-p.x, pt.y-p.y)<25) h=true;});
            container.style.cursor = h ? 'move' : 'default';
        }
    }
    function ptrUp() { if(draggingPoint) triggerAutoSave(); draggingPoint = null; }

    container.addEventListener('mousedown', ptrDown); container.addEventListener('mousemove', ptrMove); window.addEventListener('mouseup', ptrUp);
    container.addEventListener('touchstart', ptrDown, {passive:false}); container.addEventListener('touchmove', ptrMove, {passive:false}); window.addEventListener('touchend', ptrUp);

    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase()==='h') toggleUI();
        if (e.key.toLowerCase()==='f') toggleFullscreen();
        if (e.code==='Space') { const v=surfaces.find(s=>s.type==='video'&&s.mediaElement); if(v) (v.mediaElement.paused)?globalAction('play'):globalAction('pause'); }
    });

    // --- 7. Fun√ß√µes de Controle ---
    function toggleUI() {
        uiVisible = !uiVisible;
        if (uiVisible) { controlsDiv.style.display='block'; uiCanvas.style.pointerEvents='auto'; }
        else { controlsDiv.style.display='none'; uiCanvas.style.pointerEvents='none'; selectSurface(-1); }
    }
    function toggleFullscreen() { !document.fullscreenElement ? document.documentElement.requestFullscreen().catch(()=>{}) : document.exitFullscreen(); }

    function addSurface() {
        const w=300, h=200; surfaces.push(new Surface((window.innerWidth-w)/2,(window.innerHeight-h)/2,w,h));
        selectSurface(surfaces.length-1); triggerAutoSave();
    }
    function selectSurface(i) {
        selectedSurfaceIndex = i;
        const p = document.getElementById('edit-panel'), ns = document.getElementById('no-selection');
        if (i===-1) { p.style.display='none'; ns.style.display='block'; return; }
        p.style.display='block'; ns.style.display='none'; document.getElementById('sel-id').innerText="#"+i;
        const s = surfaces[i];
        document.getElementById('contentType').value=s.type;
        document.getElementById('surfColorPicker').value=s.hexColor;
        document.getElementById('urlInput').value = (s.sourceUrl && !s.isLocalFile) ? s.sourceUrl : '';
        document.getElementById('media-warning').style.display = (s.type!=='color'&&s.isLocalFile)?'block':'none';
        updateUIForType(s.type);
    }
    function deleteSurface() { if(selectedSurfaceIndex===-1)return; if(surfaces[selectedSurfaceIndex].glTexture) gl.deleteTexture(surfaces[selectedSurfaceIndex].glTexture); surfaces.splice(selectedSurfaceIndex,1); selectSurface(-1); triggerAutoSave(); }
    function moveLayer(d) { if(selectedSurfaceIndex===-1)return; const n=selectedSurfaceIndex+d; if(n>=0&&n<surfaces.length) { [surfaces[selectedSurfaceIndex],surfaces[n]]=[surfaces[n],surfaces[selectedSurfaceIndex]]; selectSurface(n); triggerAutoSave(); } }
    
    function updateUIForType(t) { document.getElementById('opt-color').style.display=t==='color'?'block':'none'; document.getElementById('opt-media').style.display=t!=='color'?'block':'none'; }
    function updateSurfaceType() { if(selectedSurfaceIndex===-1)return; const t=document.getElementById('contentType').value; surfaces[selectedSurfaceIndex].type=t; updateUIForType(t); selectSurface(selectedSurfaceIndex); triggerAutoSave(); }
    function updateBgColor() { bgColor = hexToRgb(document.getElementById('bgPicker').value); triggerAutoSave(); }
    function updateSurfColor() { if(selectedSurfaceIndex===-1)return; const h=document.getElementById('surfColorPicker').value; surfaces[selectedSurfaceIndex].hexColor=h; surfaces[selectedSurfaceIndex].glolor=hexToRgb(h); triggerAutoSave(); }
    function handleFileUpload(inp) { if(selectedSurfaceIndex===-1||!inp.files[0])return; const f=inp.files[0], u=URL.createObjectURL(f), s=surfaces[selectedSurfaceIndex]; s.isLocalFile=true; s.sourceUrl=null; applyMedia(s,u,f.type.startsWith('video')?'video':'image'); selectSurface(selectedSurfaceIndex); triggerAutoSave(); }
    function updateUrl(u) { if(selectedSurfaceIndex===-1||!u)return; const s=surfaces[selectedSurfaceIndex]; s.isLocalFile=false; s.sourceUrl=u; applyMedia(s,u,u.match(/\.(mp4|webm|ogg)$/i)?'video':'image'); triggerAutoSave(); }
    function applyMedia(s,u,t) {
        s.type=t; s.isTextureReady=false; if(s.glTexture) gl.deleteTexture(s.glTexture); s.glTexture=gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, s.glTexture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        if(t==='video') { const v=document.createElement('video'); v.crossOrigin="anonymous"; v.src=u; v.loop=true; v.muted=true; v.playsInline=true; v.addEventListener('canplay',()=>{s.isTextureReady=true;}); s.mediaElement=v; }
        else { const i=new Image(); i.crossOrigin="anonymous"; i.onload=()=>{gl.bindTexture(gl.TEXTURE_2D,s.glTexture); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,i); s.isTextureReady=true;}; i.src=u; s.mediaElement=i; }
    }
    function globalAction(a) { surfaces.forEach(s=>{if(s.type==='video'&&s.mediaElement){if(a==='play')s.mediaElement.play().catch(()=>{});if(a==='pause')s.mediaElement.pause();if(a==='reset'){s.mediaElement.currentTime=0;s.mediaElement.pause();}}}); showToast("A√ß√£o: "+a.toUpperCase()); }

    // --- 8. Persist√™ncia ---
    function getData() { return { bg: document.getElementById('bgPicker').value, surfaces: surfaces.map(s=>({pts:s.points,t:s.type,c:s.hexColor,src:s.sourceUrl,loc:s.isLocalFile})) }; }
    function loadData(d) {
        if(!d) return; if(d.bg){document.getElementById('bgPicker').value=d.bg; updateBgColor();}
        if(d.surfaces){
            surfaces.forEach(s=>{if(s.glTexture)gl.deleteTexture(s.glTexture)}); surfaces=[];
            d.surfaces.forEach(sd=>{
                const s=new Surface(0,0,100,100); s.points=sd.pts; s.type=sd.t; s.hexColor=sd.c; s.glolor=hexToRgb(sd.c); s.isLocalFile=sd.loc; s.sourceUrl=sd.src;
                if(s.type!=='color'&&!s.isLocalFile&&s.sourceUrl) applyMedia(s,s.sourceUrl,s.type); surfaces.push(s);
            }); selectSurface(-1);
        }
    }
    function triggerAutoSave() { clearTimeout(autoSaveTimeout); autoSaveTimeout=setTimeout(()=>{localStorage.setItem('mapping_autosave',JSON.stringify(getData()));},500); }
    window.onload = () => { const d=localStorage.getItem('mapping_autosave'); if(d) try{loadData(JSON.parse(d)); showToast("Restaurado");}catch(e){} };
    function exportToFile() { const b=new Blob([JSON.stringify(getData())],{type:"application/json"}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download="project.json"; a.click(); }
    function importFromFile(inp) { const f=inp.files[0]; if(!f)return; const r=new FileReader(); r.onload=e=>{try{loadData(JSON.parse(e.target.result)); triggerAutoSave(); showToast("Importado");}catch(x){alert("Erro");}}; r.readAsText(f); inp.value=''; }
    function clearAll() { if(confirm("Limpar?")) { surfaces=[]; selectSurface(-1); triggerAutoSave(); } }

    function hexToRgb(h) { const i=parseInt(h.slice(1),16); return [((i>>16)&255)/255,((i>>8)&255)/255,(i&255)/255,1.0]; }
    function showToast(m) { const t=document.getElementById('toast'); t.innerText=m; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,2000); }
</script>
</body>
</html>