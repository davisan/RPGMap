<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Projection Mapper - Persistence Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        #glCanvas { position: absolute; top:0; left:0; z-index: 1; display: block; }
        #uiCanvas { position: absolute; top:0; left:0; z-index: 2; display: block; pointer-events: none; }

        /* --- Interface --- */
        #controls {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: rgba(15, 15, 15, 0.95); color: #eee;
            padding: 15px; border-radius: 8px; width: 280px;
            border: 1px solid #333; box-shadow: 0 4px 20px rgba(0,0,0,0.8);
            transition: opacity 0.3s, transform 0.3s;
            max-height: 90vh; overflow-y: auto;
        }
        .ui-hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }

        h2 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; color: #00ffcc; letter-spacing: 1.5px; border-bottom: 1px solid #333; padding-bottom: 8px; }
        h3 { font-size: 11px; margin: 12px 0 5px; color: #888; text-transform: uppercase; letter-spacing: 1px; font-weight: bold;}

        /* Bot√µes e Inputs */
        button, select, input[type="text"] {
            width: 100%; margin-bottom: 6px; padding: 8px; box-sizing: border-box;
            background: #2a2a2a; border: 1px solid #444; color: #ddd;
            border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;
        }
        button:hover { background: #3a3a3a; border-color: #666; color: #fff; }
        button:active { transform: translateY(1px); }

        .btn-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .btn-group button { margin-bottom: 0; }
        
        /* Estilos de Bot√£o */
        .btn-primary { background: #005f73; border-color: #0a9396; }
        .btn-primary:hover { background: #0a9396; }
        .btn-danger { background: #602020; border-color: #803030; }
        .btn-danger:hover { background: #803030; }
        .btn-save { background: #204020; border-color: #306030; }
        .btn-save:hover { background: #306030; }
        
        /* Controles de Playback */
        .playback-controls {
            display: flex; gap: 2px; background: #000; padding: 4px; border-radius: 4px; border: 1px solid #333; margin-bottom: 10px;
        }
        .playback-controls button {
            background: transparent; border: none; font-size: 16px; margin: 0; padding: 5px 0;
        }
        .playback-controls button:hover { background: #222; color: #00ffcc; }

        label { font-size: 11px; color: #aaa; display: block; margin-bottom: 3px; }
        input[type="color"] { width: 100%; height: 30px; border: none; padding: 0; background: none; cursor: pointer; }
        
        /* Inputs de Arquivo Escondidos */
        #fileInput, #jsonInput { display: none; }
        
        .hint { font-size: 10px; color: #555; margin-top: 8px; font-style: italic; text-align: center;}
        
        /* Toast Notification */
        #toast {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: #fff; padding: 10px 20px; borderRadius: 20px;
            font-size: 12px; opacity: 0; transition: opacity 0.5s; pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="glCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
    </div>

    <div id="toast">Projeto Salvo!</div>

    <div id="controls">
        <h2>Mapping Pro <span style="font-size:9px; color:#666; float:right; margin-top:3px;">v3.0</span></h2>
        
        <h3>Arquivo / Estado</h3>
        <div class="btn-group">
            <button onclick="exportToFile()" class="btn-save" title="Baixar JSON">üíæ Salvar Arq.</button>
            <button onclick="document.getElementById('jsonInput').click()" title="Carregar JSON">üìÇ Abrir Arq.</button>
            <input type="file" id="jsonInput" accept=".json" onchange="importFromFile(this)">
        </div>
        <button onclick="clearAll()" class="btn-danger" style="padding: 4px;">Limpar Tudo</button>

        <h3>Maestro (Sync)</h3>
        <div class="playback-controls">
            <button onclick="globalAction('play')" title="Play Todos">‚ñ∂</button>
            <button onclick="globalAction('pause')" title="Pause Todos">‚è∏</button>
            <button onclick="globalAction('reset')" title="Reiniciar Todos">‚èÆ</button>
        </div>

        <h3>Global</h3>
        <div class="btn-group">
            <div style="flex:1">
                <input type="color" id="bgPicker" value="#000000" oninput="updateBgColor()" title="Cor de Fundo">
            </div>
            <div style="flex:3">
                <button onclick="toggleUI(false)">Ocultar UI (H)</button>
            </div>
        </div>
        <button onclick="addSurface()" class="btn-primary" style="font-weight:bold; margin-top:5px;">+ Adicionar Tela</button>

        <div id="edit-panel" style="display:none; margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
            <h3 style="color: #00ffcc;">Propriedades da Sele√ß√£o</h3>
            
            <div class="btn-group">
                <button onclick="moveLayer(-1)">‚ñº Tr√°s</button>
                <button onclick="moveLayer(1)">‚ñ≤ Frente</button>
            </div>

            <label>Tipo de Conte√∫do:</label>
            <select id="contentType" onchange="updateSurfaceType()">
                <option value="color">Cor S√≥lida</option>
                <option value="image">Imagem</option>
                <option value="video">V√≠deo</option>
            </select>

            <div id="opt-color" class="opts">
                <label>Cor:</label>
                <input type="color" id="surfColorPicker" oninput="updateSurfColor()" value="#00ffcc">
            </div>

            <div id="opt-media" class="opts" style="display:none;">
                <button onclick="document.getElementById('fileInput').click()">üìÅ Carregar M√≠dia</button>
                <input type="text" id="urlInput" placeholder="URL (Imagem/Video)..." onchange="updateUrl(this.value)">
                <input type="file" id="fileInput" accept="image/*,video/*" onchange="handleFileUpload(this)">
                <div id="media-warning" style="font-size: 9px; color: #d88; margin-top:4px; display:none;">
                    * Arquivo local. Ao recarregar a p√°gina, voc√™ precisar√° selecionar o arquivo novamente.
                </div>
            </div>
            
            <button onclick="deleteSurface()" class="btn-danger" style="margin-top:10px;">Remover Tela</button>
        </div>

        <div id="no-selection" style="color:#444; font-size: 11px; text-align: center; padding: 15px 0;">
            [ Nenhuma tela selecionada ]
        </div>
    </div>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform mat4 u_matrix;
    varying vec2 v_texCoord;
    void main() {
        vec4 position = u_matrix * vec4(a_position, 0.0, 1.0);
        gl_Position = vec4(position.xy / position.w, 0.0, 1.0);
        v_texCoord = a_texCoord;
    }
</script>
<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_texture;
    uniform vec4 u_color;
    uniform bool u_useTexture;
    varying vec2 v_texCoord;
    void main() {
        if (u_useTexture) {
            gl_FragColor = texture2D(u_texture, v_texCoord);
        } else {
            gl_FragColor = u_color;
        }
    }
</script>

<script>
    // --- Configura√ß√£o B√°sica ---
    const glCanvas = document.getElementById('glCanvas');
    const uiCanvas = document.getElementById('uiCanvas');
    const gl = glCanvas.getContext('webgl', { alpha: false, preserveDrawingBuffer: true });
    const ctx = uiCanvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const controlsDiv = document.getElementById('controls');

    if (!gl) alert("Erro: WebGL n√£o suportado.");

    function resize() {
        glCanvas.width = uiCanvas.width = window.innerWidth;
        glCanvas.height = uiCanvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Estado da Aplica√ß√£o ---
    let surfaces = [];
    let selectedSurfaceIndex = -1;
    let draggingPoint = null;
    let bgColor = [0, 0, 0, 1];
    let uiVisible = true;
    let autoSaveTimeout = null;

    // --- Classe Surface ---
    class Surface {
        constructor(x, y, w, h) {
            this.points = [{x,y}, {x:x+w, y}, {x:x+w, y:y+h}, {x, y:y+h}];
            this.type = 'color';
            this.glolor = [0.0, 1.0, 0.8, 1.0];
            this.hexColor = "#00ffcc";
            this.mediaElement = null;
            this.glTexture = null;
            this.isTextureReady = false;
            
            // Persist√™ncia
            this.sourceUrl = null; // Guarda URL remota
            this.isLocalFile = false; // Flag para saber se era arquivo local
        }
    }

    // --- WebGL Setup ---
    function createShader(gl, type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) return null;
        return s;
    }
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text));
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
    
    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);

    const locs = {
        pos: gl.getAttribLocation(program, "a_position"),
        tex: gl.getAttribLocation(program, "a_texCoord"),
        mat: gl.getUniformLocation(program, "u_matrix"),
        uTex: gl.getUniformLocation(program, "u_texture"),
        col: gl.getUniformLocation(program, "u_color"),
        useT: gl.getUniformLocation(program, "u_useTexture")
    };

    const placeholderTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, placeholderTex);
    // Placeholder xadrez para indicar "Falta M√≠dia"
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([50,50,50,255]));

    // --- Matem√°tica Homografia ---
    function computeHomographyMatrix(points, width, height) {
        const p = points.map(pt => ({ x: (pt.x/width)*2-1, y: 1-(pt.y/height)*2 }));
        const s = [{x:0,y:0}, {x:1,y:0}, {x:1,y:1}, {x:0,y:1}];
        const a = [], b = [];
        for(let i=0; i<4; ++i) {
            a.push([s[i].x, s[i].y, 1, 0, 0, 0, -s[i].x*p[i].x, -s[i].y*p[i].x]);
            a.push([0, 0, 0, s[i].x, s[i].y, 1, -s[i].x*p[i].y, -s[i].y*p[i].y]);
            b.push(p[i].x); b.push(p[i].y);
        }
        const n=8;
        for (let i=0; i<n; ++i) {
            let max=Math.abs(a[i][i]), row=i;
            for(let k=i+1; k<n; ++k) if(Math.abs(a[k][i])>max){max=Math.abs(a[k][i]); row=k;}
            for(let k=i; k<n; ++k) {const t=a[row][k]; a[row][k]=a[i][k]; a[i][k]=t;}
            const t=b[row]; b[row]=b[i]; b[i]=t;
            for(let k=i+1; k<n; ++k) {
                const c=-a[k][i]/a[i][i];
                for(let j=i; j<n; ++j) a[k][j]+=c*a[i][j];
                b[k]+=c*b[i];
            }
        }
        const x=new Array(n).fill(0);
        for(let i=n-1; i>=0; --i) {
            let sum=0; for(let j=i+1; j<n; ++j) sum+=a[i][j]*x[j];
            x[i]=(b[i]-sum)/a[i][i];
        }
        return [x[0], x[3], 0, x[6], x[1], x[4], 0, x[7], 0, 0, 1, 0, x[2], x[5], 0, 1];
    }

    // --- Render Loop ---
    function renderWebGL() {
        gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(locs.pos, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locs.pos);
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.vertexAttribPointer(locs.tex, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locs.tex);

        surfaces.forEach(surf => {
            const m = computeHomographyMatrix(surf.points, glCanvas.width, glCanvas.height);
            gl.uniformMatrix4fv(locs.mat, false, m);

            if (surf.type === 'color') {
                gl.uniform1i(locs.useT, 0);
                gl.uniform4fv(locs.col, surf.glolor);
            } else {
                gl.uniform1i(locs.useT, 1);
                gl.activeTexture(gl.TEXTURE0);
                
                if (surf.type === 'video' && surf.mediaElement && surf.isTextureReady) {
                     gl.bindTexture(gl.TEXTURE_2D, surf.glTexture);
                     try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, surf.mediaElement); } catch(e) {}
                } else if (surf.glTexture && surf.isTextureReady) {
                     gl.bindTexture(gl.TEXTURE_2D, surf.glTexture);
                } else {
                     gl.bindTexture(gl.TEXTURE_2D, placeholderTex);
                }
                gl.uniform1i(locs.uTex, 0);
            }
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        });
    }

    function renderUI() {
        ctx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        if (!uiVisible) return;

        surfaces.forEach((surf, index) => {
            const isSelected = index === selectedSurfaceIndex;
            ctx.beginPath();
            ctx.moveTo(surf.points[0].x, surf.points[0].y);
            surf.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();

            if (isSelected) {
                ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#fff';
                surf.points.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                });
                // ID e Aviso de M√≠dia Perdida
                const cx = (surf.points[0].x + surf.points[2].x)/2;
                const cy = (surf.points[0].y + surf.points[2].y)/2;
                ctx.fillStyle = "#00ffcc"; ctx.font="12px sans-serif"; ctx.fillText("#"+index, cx-5, cy);
                
                if(surf.isLocalFile && !surf.isTextureReady) {
                    ctx.fillStyle = "#ff4444"; ctx.fillText("Recarregar Arquivo!", cx-50, cy+20);
                }
            } else {
                ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1; ctx.stroke();
            }
        });
    }

    function animate() {
        renderWebGL();
        renderUI();
        requestAnimationFrame(animate);
    }
    animate();

    // --- Persist√™ncia (Salvar/Carregar) ---

    // Estrutura do objeto para JSON/Storage
    function getSceneData() {
        return {
            bg: document.getElementById('bgPicker').value,
            surfaces: surfaces.map(s => ({
                points: s.points,
                type: s.type,
                hexColor: s.hexColor,
                sourceUrl: s.sourceUrl,
                isLocalFile: s.isLocalFile
            }))
        };
    }

    function loadSceneData(data) {
        if(!data) return;
        
        // 1. Restaurar Fundo
        if(data.bg) {
            document.getElementById('bgPicker').value = data.bg;
            updateBgColor();
        }

        // 2. Restaurar Superf√≠cies
        if(data.surfaces) {
            // Limpa texturas antigas
            surfaces.forEach(s => { if(s.glTexture) gl.deleteTexture(s.glTexture); });
            surfaces = [];

            data.surfaces.forEach(sd => {
                // Cria nova surface
                // Pega o bounding box para criar (ser√° sobrescrito pelos points)
                const surf = new Surface(0,0,100,100);
                surf.points = sd.points; // Restaura geometria exata
                surf.type = sd.type;
                surf.hexColor = sd.hexColor;
                surf.glolor = hexToRgbGL(sd.hexColor);
                surf.isLocalFile = sd.isLocalFile;
                surf.sourceUrl = sd.sourceUrl;

                // Tenta restaurar m√≠dia
                if (surf.type !== 'color') {
                    if (surf.isLocalFile) {
                        // N√£o faz nada, espera usu√°rio carregar arquivo
                        // A renderiza√ß√£o mostrar√° placeholder
                    } else if (surf.sourceUrl) {
                        // URL remota, recarrega
                        applyMediaToSurface(surf, surf.sourceUrl, surf.type);
                    }
                }
                surfaces.push(surf);
            });
            selectSurface(-1);
        }
    }

    // Auto-Save no LocalStorage
    function triggerAutoSave() {
        clearTimeout(autoSaveTimeout);
        autoSaveTimeout = setTimeout(() => {
            const data = getSceneData();
            localStorage.setItem('mapper_autosave', JSON.stringify(data));
        }, 500); // Salva 500ms ap√≥s √∫ltima altera√ß√£o
    }

    // Carregar do Auto-Save ao Iniciar
    window.addEventListener('load', () => {
        const saved = localStorage.getItem('mapper_autosave');
        if(saved) {
            try {
                loadSceneData(JSON.parse(saved));
                showToast("Estado restaurado.");
            } catch(e) { console.error("Erro ao carregar auto-save", e); }
        }
    });

    // Arquivo JSON - Exportar
    function exportToFile() {
        const data = getSceneData();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "projeto_mapping.json";
        a.click();
        URL.revokeObjectURL(url);
        showToast("Arquivo salvo!");
    }

    // Arquivo JSON - Importar
    function importFromFile(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                loadSceneData(data);
                triggerAutoSave();
                showToast("Projeto carregado!");
            } catch(err) {
                alert("Erro ao ler arquivo JSON.");
            }
        };
        reader.readAsText(file);
        input.value = ''; // Reset input
    }
    
    function clearAll() {
        if(confirm("Tem certeza que deseja apagar tudo?")) {
            surfaces = [];
            selectSurface(-1);
            triggerAutoSave();
        }
    }

    // --- L√≥gica Geral e Eventos ---

    function globalAction(action) {
        surfaces.forEach(surf => {
            if (surf.type === 'video' && surf.mediaElement) {
                if(action === 'play') surf.mediaElement.play().catch(e=>{});
                if(action === 'pause') surf.mediaElement.pause();
                if(action === 'reset') { surf.mediaElement.currentTime = 0; surf.mediaElement.pause(); }
            }
        });
    }

	/*
    function toggleUI(show) {
        uiVisible = (show !== undefined) ? show : !uiVisible;
        if (uiVisible) {
            controlsDiv.classList.remove('ui-hidden');
            uiCanvas.style.pointerEvents = 'auto';
        } else {
            controlsDiv.classList.add('ui-hidden');
            uiCanvas.style.pointerEvents = 'none';
            selectSurface(-1);
        }
    }
	*/
	function toggleUI(show) {
        // Define o estado (se show for indefinido, inverte o atual)
        const targetState = (show !== undefined) ? show : !uiVisible;

        // Se o estado n√£o mudou, n√£o faz nada (evita loops)
        if (targetState === uiVisible) return;

        uiVisible = targetState;

        if (uiVisible) {
            // MOSTRAR INTERFACE
            controlsDiv.classList.remove('ui-hidden');
            uiCanvas.style.pointerEvents = 'auto';
            
            // Sai da tela cheia se estiver nela
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(err => console.log("Erro ao sair tela cheia:", err));
            }
        } else {
            // ESCONDER INTERFACE
            controlsDiv.classList.add('ui-hidden');
            uiCanvas.style.pointerEvents = 'none';
            selectSurface(-1); // Deseleciona
            
            // Entra em tela cheia (apenas se n√£o estiver)
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn("Tela cheia bloqueada (requer intera√ß√£o do usu√°rio):", err);
                });
            }
        }
    }
	document.addEventListener('fullscreenchange', () => {
        // Se saiu da tela cheia (document.fullscreenElement √© null), for√ßa a UI a aparecer
        if (!document.fullscreenElement) {
            toggleUI(true);
        }
    });
	
	function getPointerPos(e) {
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
    }

    function handlePointerDown(e) {
        if (!uiVisible) return;
        
        // Impede que a tela role ou d√™ zoom ao tocar no canvas
        if (e.cancelable && e.touches) e.preventDefault();

        const mp = getPointerPos(e);
        let clickedCorner = false;

        // 1. Tenta pegar um canto (Corner)
        if (selectedSurfaceIndex !== -1) {
            surfaces[selectedSurfaceIndex].points.forEach((p, idx) => {
                // Aumentei um pouco a √°rea de toque para 25px para facilitar no tablet
                if (Math.hypot(p.x - mp.x, p.y - mp.y) < 25) { 
                    draggingPoint = { surfIdx: selectedSurfaceIndex, ptIdx: idx }; 
                    clickedCorner = true; 
                }
            });
        }

        // 2. Se n√£o pegou canto, tenta selecionar a superf√≠cie
        if (!clickedCorner) {
            let found = -1;
            for (let i = surfaces.length - 1; i >= 0; i--) {
                const vs = surfaces[i].points;
                let inside = false;
                for (let j = 0, k = vs.length - 1; j < vs.length; k = j++) {
                    if (((vs[j].y > mp.y) != (vs[k].y > mp.y)) && 
                        (mp.x < (vs[k].x - vs[j].x) * (mp.y - vs[j].y) / (vs[k].y - vs[j].y) + vs[j].x)) {
                        inside = !inside;
                    }
                }
                if(inside) { found = i; break; }
            }
            selectSurface(found);
        }
    }

    function handlePointerMove(e) {
        if (!uiVisible) return;
        if (e.touches) e.preventDefault(); // Bloqueia scroll no tablet

        const mp = getPointerPos(e);

        if (draggingPoint) {
            const p = surfaces[draggingPoint.surfIdx].points[draggingPoint.ptIdx];
            p.x = mp.x; 
            p.y = mp.y;
        } else {
            // L√≥gica do cursor (apenas visual para mouse)
            let hovering = false;
            if(selectedSurfaceIndex > -1) {
                surfaces[selectedSurfaceIndex].points.forEach(p=>{
                    if(Math.hypot(p.x - mp.x, p.y - mp.y) < 25) hovering=true;
                });
            }
            container.style.cursor = hovering ? 'move' : 'default';
        }
    }

    function handlePointerUp(e) {
        if (draggingPoint) triggerAutoSave();
        draggingPoint = null;
    }

    // Mouse Interactions (Adicionado triggerAutoSave)
	
    /*container.addEventListener('mousedown', e => {
        if (!uiVisible) return;
        const mp = {x: e.clientX, y: e.clientY};
        let clickedCorner = false;
        if (selectedSurfaceIndex !== -1) {
            surfaces[selectedSurfaceIndex].points.forEach((p, idx) => {
                if (Math.hypot(p.x - mp.x, p.y - mp.y) < 15) { 
                    draggingPoint = { surfIdx: selectedSurfaceIndex, ptIdx: idx }; 
                    clickedCorner = true; 
                }
            });
        }
        if (!clickedCorner) {
            let found = -1;
            for (let i = surfaces.length - 1; i >= 0; i--) {
                // Ray casting simples
                const vs = surfaces[i].points;
                let inside = false;
                for (let j = 0, k = vs.length - 1; j < vs.length; k = j++) {
                    if (((vs[j].y > mp.y) != (vs[k].y > mp.y)) && (mp.x < (vs[k].x - vs[j].x) * (mp.y - vs[j].y) / (vs[k].y - vs[j].y) + vs[j].x)) inside = !inside;
                }
                if(inside) { found = i; break; }
            }
            selectSurface(found);
        }
    });
	*/

    /*container.addEventListener('mousemove', e => {
        if (!uiVisible) return;
        if (draggingPoint) {
            const p = surfaces[draggingPoint.surfIdx].points[draggingPoint.ptIdx];
            p.x = e.clientX; p.y = e.clientY;
        } else {
            let hovering = false;
            if(selectedSurfaceIndex > -1) {
                surfaces[selectedSurfaceIndex].points.forEach(p=>{if(Math.hypot(p.x - e.clientX, p.y - e.clientY)<15) hovering=true;});
            }
            container.style.cursor = hovering ? 'move' : 'default';
        }
    });
	*/

    container.addEventListener('mousedown', handlePointerDown);
	container.addEventListener('mousemove', handlePointerMove);
	window.addEventListener('mouseup', handlePointerUp);
	
	/*window.addEventListener('mouseup', () => {
        if(draggingPoint) triggerAutoSave(); // Salva ao soltar o mouse
        draggingPoint = null;
    });
	*/

	container.addEventListener('touchstart', handlePointerDown, { passive: false });
    container.addEventListener('touchmove', handlePointerMove, { passive: false });
    window.addEventListener('touchend', handlePointerUp);

    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'h' || e.key === 'Escape') toggleUI();
        if (e.code === 'Space') {
            const v = surfaces.find(s => s.type === 'video' && s.mediaElement);
            if(v) (v.mediaElement.paused) ? globalAction('play') : globalAction('pause');
        }
    });

    // Helpers UI e CRUD
    function addSurface() {
        const w = 300, h = 200;
        surfaces.push(new Surface((window.innerWidth-w)/2, (window.innerHeight-h)/2, w, h));
        selectSurface(surfaces.length - 1);
        triggerAutoSave();
    }
    
    function selectSurface(i) {
        selectedSurfaceIndex = i;
        const panel = document.getElementById('edit-panel');
        const noSel = document.getElementById('no-selection');
        if (i === -1) { panel.style.display='none'; noSel.style.display='block'; return;}
        panel.style.display='block'; noSel.style.display='none';
        
        const s = surfaces[i];
        document.getElementById('contentType').value = s.type;
        document.getElementById('surfColorPicker').value = s.hexColor;
        document.getElementById('urlInput').value = (s.sourceUrl && !s.isLocalFile) ? s.sourceUrl : '';
        
        // Aviso de arquivo local
        document.getElementById('media-warning').style.display = (s.type !== 'color' && s.isLocalFile) ? 'block' : 'none';
        
        updateUIForType(s.type);
    }

    function deleteSurface() {
        if(selectedSurfaceIndex===-1)return;
        const s = surfaces[selectedSurfaceIndex];
        if(s.glTexture) gl.deleteTexture(s.glTexture);
        surfaces.splice(selectedSurfaceIndex,1);
        selectSurface(-1);
        triggerAutoSave();
    }

    function moveLayer(dir) {
        if(selectedSurfaceIndex===-1)return;
        const nIdx = selectedSurfaceIndex + dir;
        if(nIdx < 0 || nIdx >= surfaces.length) return;
        [surfaces[selectedSurfaceIndex], surfaces[nIdx]] = [surfaces[nIdx], surfaces[selectedSurfaceIndex]];
        selectSurface(nIdx);
        triggerAutoSave();
    }

    // Handlers de UI
    function updateUIForType(t) {
        document.getElementById('opt-color').style.display = t === 'color' ? 'block' : 'none';
        document.getElementById('opt-media').style.display = (t === 'image' || t === 'video') ? 'block' : 'none';
    }
    
    function updateSurfaceType() {
        if(selectedSurfaceIndex===-1)return;
        const t = document.getElementById('contentType').value;
        surfaces[selectedSurfaceIndex].type = t;
        updateUIForType(t);
        selectSurface(selectedSurfaceIndex); // Atualiza avisos
        triggerAutoSave();
    }
    
    function updateBgColor() {
        const h = document.getElementById('bgPicker').value;
        bgColor = hexToRgbGL(h);
        triggerAutoSave();
    }
    
    function updateSurfColor() {
        if(selectedSurfaceIndex===-1)return;
        const h = document.getElementById('surfColorPicker').value;
        surfaces[selectedSurfaceIndex].hexColor = h;
        surfaces[selectedSurfaceIndex].glolor = hexToRgbGL(h);
        triggerAutoSave();
    }

    // Media Handling
    function handleFileUpload(input) {
        if(selectedSurfaceIndex===-1 || !input.files[0]) return;
        const f = input.files[0];
        const u = URL.createObjectURL(f);
        const t = f.type.startsWith('video') ? 'video' : 'image';
        
        const s = surfaces[selectedSurfaceIndex];
        s.isLocalFile = true; // Marca como local
        s.sourceUrl = null; // N√£o salvamos blob URL
        
        applyMediaToSurface(s, u, t);
        selectSurface(selectedSurfaceIndex); // Atualiza UI (aviso)
        triggerAutoSave();
    }

    function updateUrl(u) {
        if(selectedSurfaceIndex===-1) return;
        if (!u) return;
        
        const s = surfaces[selectedSurfaceIndex];
        const isV = u.match(/\.(mp4|webm|ogg|mov)$/i);
        s.isLocalFile = false; // URL remota
        s.sourceUrl = u;       // Salva URL
        
        applyMediaToSurface(s, u, isV ? 'video' : 'image');
        triggerAutoSave();
    }

    function applyMediaToSurface(s, url, type) {
        s.type = type; 
        s.isTextureReady = false;
        if(s.glTexture) gl.deleteTexture(s.glTexture);
        s.glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, s.glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        
        if (type === 'video') {
            const v = document.createElement('video');
            v.crossOrigin = "anonymous";
            v.src = url; v.loop = true; v.muted = true; v.autoplay = false; v.playsInline = true;
            v.addEventListener('canplay', () => { s.isTextureReady = true; });
            s.mediaElement = v;
        } else {
            const i = new Image();
            i.crossOrigin = "anonymous";
            i.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, s.glTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);
                s.isTextureReady = true;
            };
            i.src = url;
            s.mediaElement = i;
        }
    }

    // Utils
    function hexToRgbGL(hex) {
        const bi = parseInt(hex.slice(1), 16);
        return [((bi>>16)&255)/255, ((bi>>8)&255)/255, (bi&255)/255, 1.0];
    }
    
    function showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity = 1;
        setTimeout(() => t.style.opacity = 0, 2000);
    }

</script>
</body>
</html>