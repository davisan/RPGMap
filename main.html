<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Criador de Mapas RPG - Com Fundo</title>
    <style>
        /* --- ESTILOS GERAIS E LAYOUT FIXO (Mantidos) --- */
        * { box-sizing: border-box; }
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; -webkit-user-select: none; user-select: none; touch-action: none; 
        }
        body { display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 280px; background-color: #34495e; display: flex; flex-direction: column;
            padding: 15px; gap: 15px; box-shadow: 2px 0 5px rgba(0,0,0,0.3); z-index: 10;
            overflow-y: auto; touch-action: pan-y;
        }
        .sidebar h2 { margin: 0 0 10px 0; font-size: 1.2rem; text-align: center; border-bottom: 2px solid #2ecc71; padding-bottom: 10px; }
        .control-group { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; }
        .control-group h3 { margin: 0 0 8px 0; font-size: 0.9rem; color: #bdc3c7; text-transform: uppercase; }
        .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .input-row label { font-size: 0.85rem; color: #ecf0f1; }
        input[type="number"], select { width: 70px; padding: 6px; border-radius: 3px; border: none; background: #ecf0f1; }
        input[type="range"] { width: 100%; height: 20px; }
        input[type="color"] { border: none; width: 100%; height: 35px; padding: 0; background: none; }

        /* Bot√µes */
        button {
            width: 100%; padding: 12px; background-color: #27ae60; color: white;
            border: none; border-radius: 4px; font-weight: bold; margin-top: 5px; font-size: 0.9rem;
        }
        button:active { filter: brightness(0.9); transform: scale(0.98); }
        .file-btn { background-color: #8e44ad; flex: 1; }
        .bg-btn { background-color: #d35400; flex: 1; font-size: 0.8rem;} /* Bot√£o laranja para fundo */
        .save-img-btn { background-color: #2980b9; }
        .reset-btn { background-color: #c0392b; }
        
        /* Ferramentas */
        .tools-row { display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap; }
        .tool-btn { background-color: #7f8c8d; flex: 1; padding: 15px 5px; }
        .tool-btn.active { background-color: #3498db; border: 2px solid #2980b9; }
        .action-buttons { display: flex; gap: 5px; margin-top: 5px; }
        .action-buttons button { background-color: #f39c12; }
        .action-buttons button:disabled { background-color: #7f8c8d; opacity: 0.6; }

        /* --- VIEWPORT E CAMADAS --- */
        .viewport {
            flex-grow: 1; background-color: #95a5a6; display: flex;
            justify-content: center; align-items: center; overflow: hidden;
            position: relative; touch-action: none;
        }
        #content-wrapper { position: absolute; top: 0; left: 0; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #map-container { position: relative; background-color: white; flex-shrink: 0; }

        canvas { position: absolute; top: 0; left: 0; }
        
        /* Ordem das Camadas */
        #bgLayer { z-index: 0; pointer-events: none; }   /* Fundo (atr√°s de tudo) */
        #gridLayer { z-index: 1; pointer-events: none; } /* Grade (meio) */
        #drawLayer { z-index: 2; }                       /* Desenho (frente, recebe cliques) */

    </style>
</head>
<body>

    <aside class="sidebar">
        <h2>üó∫Ô∏è RPG Map Maker</h2>
        
        <div class="control-group">
            <h3>Arquivo & Fundo</h3>
            <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                <button class="file-btn" onclick="saveProjectFile()">üíæ Salvar</button>
                <button class="file-btn" onclick="document.getElementById('fileInput').click()">üìÇ Abrir</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadProjectFile(this)">
            </div>
            <div style="display: flex; gap: 5px;">
                <button class="bg-btn" onclick="document.getElementById('bgInput').click()">üñºÔ∏è P√¥r Fundo</button>
                <button class="bg-btn" onclick="clearBackground()" style="background-color: #c0392b;">‚ùå Tirar</button>
                 <input type="file" id="bgInput" accept="image/*" style="display: none;" onchange="loadBackground(this)">
            </div>
             <button class="save-img-btn" onclick="exportImage()" style="margin-top: 10px;">üì∑ Baixar Imagem Final</button>
        </div>

        <div class="control-group">
            <h3>Configurar Mapa</h3>
            <div class="input-row"><label>Largura</label><input type="number" id="mapCols" value="20" min="5" max="100"></div>
            <div class="input-row"><label>Altura</label><input type="number" id="mapRows" value="15" min="5" max="100"></div>
            <div class="input-row"><label>C√©lula</label><input type="number" id="cellSize" value="40" min="10" max="100"></div>
            <button class="reset-btn" onclick="resizeMap(true)">Novo Mapa (Limpar)</button>
        </div>

        <div class="control-group">
            <h3>Grade</h3>
            <div class="input-row"><label>Cor</label><div style="width: 60px;"><input type="color" id="gridColor" value="#cccccc" oninput="updateGrid()"></div></div>
            <div class="input-row" style="flex-direction: column; align-items: flex-start;">
                <label>Espessura</label><input type="range" id="gridWidth" min="1" max="5" value="1" oninput="updateGrid()">
            </div>
            <div class="input-row">
                <label>Estilo</label>
                <select id="gridPattern" onchange="updateGrid()">
                    <option value="solid">S√≥lido</option>
                    <option value="dashed">Tracejado</option>
                    <option value="dotted">Pontilhado</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <h3>Ferramentas</h3>
            <div class="tools-row">
                <button id="btnPan" class="tool-btn" onclick="setTool('pan')">üñê Mover</button>
                <button id="btnBrush" class="tool-btn" onclick="setTool('brush')">üñåÔ∏è Pincel</button>
                <button id="btnEraser" class="tool-btn" onclick="setTool('eraser')">üßΩ Borracha</button>
            </div>

            <div class="input-row"><label>Cor Pincel</label><div style="width: 60px;"><input type="color" id="brushColor" value="#2c3e50"></div></div>
            <div class="input-row" style="flex-direction: column; align-items: flex-start;">
                <label>Tamanho</label><input type="range" id="brushSize" min="1" max="50" value="5">
            </div>
            
            <div class="action-buttons">
                <button onclick="undo()" id="btnUndo" title="Undo">‚Ü∂ Undo</button>
                <button onclick="redo()" id="btnRedo" title="Redo">‚Ü∑ Redo</button>
            </div>
        </div>
    </aside>

    <main class="viewport" id="mainViewport">
        <div id="content-wrapper">
            <div id="map-container">
                <canvas id="bgLayer"></canvas>
                <canvas id="gridLayer"></canvas>
                <canvas id="drawLayer"></canvas>
            </div>
        </div>
    </main>

    <script>
        // --- CONFIGURA√á√ÉO E REFER√äNCIAS ---
        const LOCAL_STORAGE_KEY = 'rpgMapData_v2_bg';
        const viewport = document.getElementById('mainViewport');
        const contentWrapper = document.getElementById('content-wrapper');
        const container = document.getElementById('map-container');
        
        // Refer√™ncias aos 3 Canvas
        const bgCanvas = document.getElementById('bgLayer');
        const gridCanvas = document.getElementById('gridLayer');
        const drawCanvas = document.getElementById('drawLayer');
        
        const bgCtx = bgCanvas.getContext('2d');
        const gridCtx = gridCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        
        const inputs = {
            cols: document.getElementById('mapCols'), rows: document.getElementById('mapRows'), cellSize: document.getElementById('cellSize'),
            gridColor: document.getElementById('gridColor'), gridWidth: document.getElementById('gridWidth'), gridPattern: document.getElementById('gridPattern'),
            brushColor: document.getElementById('brushColor'), brushSize: document.getElementById('brushSize')
        };
        const btns = {
            pan: document.getElementById('btnPan'), brush: document.getElementById('btnBrush'), eraser: document.getElementById('btnEraser'),
            undo: document.getElementById('btnUndo'), redo: document.getElementById('btnRedo')
        };

        // --- ESTADO DO APLICATIVO ---
        let state = {
            isActionActive: false, tool: 'pan',
            lastX: 0, lastY: 0,
            panStartX: 0, panStartY: 0, offsetX: 50, offsetY: 50,
            bgImageSrc: null // Armazena a imagem de fundo atual (Base64)
        };

        let history = []; let historyStep = -1;

        // --- INICIALIZA√á√ÉO ---
        window.onload = () => {
            if (!loadFromLocalStorage()) { resizeMap(true); } else { updateViewTransform(); }
            setTool('pan');
        };

        // --- L√ìGICA DE INPUT (TOUCH/MOUSE) ---
        function getPointerPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top, rawX: clientX, rawY: clientY };
        }
        function handleStart(e) {
            if (e.cancelable) e.preventDefault();
            state.isActionActive = true; const pos = getPointerPos(e);
            if (state.tool === 'pan') {
                state.panStartX = pos.rawX - state.offsetX; state.panStartY = pos.rawY - state.offsetY; viewport.style.cursor = 'grabbing';
            } else {
                state.lastX = pos.x; state.lastY = pos.y; performDraw(pos.x, pos.y);
            }
        }
        function handleMove(e) {
            if (!state.isActionActive) return; if (e.cancelable) e.preventDefault(); const pos = getPointerPos(e);
            if (state.tool === 'pan') { state.offsetX = pos.rawX - state.panStartX; state.offsetY = pos.rawY - state.panStartY; updateViewTransform(); } 
            else { performDraw(pos.x, pos.y); }
        }
        function handleEnd(e) {
            if (state.isActionActive) {
                state.isActionActive = false;
                if (state.tool === 'pan') { viewport.style.cursor = 'grab'; } 
                else { saveHistoryState(); autoSave(); }
            }
        }
        viewport.addEventListener('mousedown', handleStart); viewport.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('mousemove', handleMove); window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('mouseup', handleEnd); window.addEventListener('touchend', handleEnd);

        function updateViewTransform() { contentWrapper.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px)`; }
        function performDraw(currX, currY) {
            drawCtx.beginPath(); drawCtx.moveTo(state.lastX, state.lastY); drawCtx.lineTo(currX, currY);
            drawCtx.lineWidth = inputs.brushSize.value; drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
            if (state.tool === 'brush') { drawCtx.globalCompositeOperation = 'source-over'; drawCtx.strokeStyle = inputs.brushColor.value; } 
            else { drawCtx.globalCompositeOperation = 'destination-out'; drawCtx.strokeStyle = "rgba(0,0,0,1)"; }
            drawCtx.stroke(); [state.lastX, state.lastY] = [currX, currY];
        }

        // --- ARQUIVOS E PERSIST√äNCIA ---
        // Fun√ß√£o auxiliar para coletar dados atuais
        function getCurrentMapData() {
            return {
                cols: inputs.cols.value, rows: inputs.rows.value, cellSize: inputs.cellSize.value,
                gridColor: inputs.gridColor.value, gridWidth: inputs.gridWidth.value, gridPattern: inputs.gridPattern.value,
                image: drawCanvas.toDataURL(),
                bgImage: state.bgImageSrc // Inclui o fundo no salvamento
            };
        }

        function autoSave() { localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(getCurrentMapData())); }
        
        function saveProjectFile() {
            const data = getCurrentMapData();
            const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = "mapa-rpg-bg.json"; a.click(); URL.revokeObjectURL(url);
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem(LOCAL_STORAGE_KEY); if (!saved) return false;
            try { applyMapData(JSON.parse(saved)); return true; } catch (e) { return false; }
        }
        function loadProjectFile(input) {
            const file = input.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => { try { applyMapData(JSON.parse(e.target.result)); autoSave(); } catch (err) { alert("Erro ao ler arquivo."); } };
            reader.readAsText(file); input.value = '';
        }

        function applyMapData(data) {
            inputs.cols.value = data.cols; inputs.rows.value = data.rows; inputs.cellSize.value = data.cellSize;
            inputs.gridColor.value = data.gridColor || '#cccccc'; inputs.gridWidth.value = data.gridWidth || 1; inputs.gridPattern.value = data.gridPattern || 'solid';
            state.bgImageSrc = data.bgImage || null; // Carrega o fundo
            resizeCanvasStruct(); 
            drawGrid();
            drawBackground(); // Desenha o fundo carregado
            if (data.image) {
                const img = new Image(); img.src = data.image;
                img.onload = () => {
                    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height); drawCtx.drawImage(img, 0, 0);
                    history = [drawCanvas.toDataURL()]; historyStep = 0; updateButtons();
                };
            }
        }

        // --- NOVA FUNCIONALIDADE: IMAGEM DE FUNDO ---
        function loadBackground(input) {
            const file = input.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                state.bgImageSrc = e.target.result; // Salva a imagem em mem√≥ria
                drawBackground(); // Desenha no canvas de fundo
                autoSave();
            };
            reader.readAsDataURL(file);
            input.value = '';
        }

        function drawBackground() {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            if (!state.bgImageSrc) return;
            const img = new Image();
            img.src = state.bgImageSrc;
            img.onload = () => {
                // Desenha a imagem esticada para preencher todo o mapa
                bgCtx.drawImage(img, 0, 0, bgCanvas.width, bgCanvas.height);
            };
        }

        function clearBackground() {
            state.bgImageSrc = null;
            drawBackground();
            autoSave();
        }

        // --- EXPORTAR IMAGEM FINAL ---
        function exportImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = drawCanvas.width; tempCanvas.height = drawCanvas.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = "#ffffff"; tCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
            
            // Ordem de desenho importante: Fundo -> Grade -> Desenho
            if (state.bgImageSrc) tCtx.drawImage(bgCanvas, 0, 0);
            tCtx.drawImage(gridCanvas, 0, 0); 
            tCtx.drawImage(drawCanvas, 0, 0);
            
            const link = document.createElement('a'); link.download = 'mapa-rpg-completo.png'; link.href = tempCanvas.toDataURL(); link.click();
        }

        // --- MAPA UTILS ---
        function updateGrid() { drawGrid(); autoSave(); }
        function resizeCanvasStruct() {
            const w = parseInt(inputs.cols.value) * parseInt(inputs.cellSize.value); const h = parseInt(inputs.rows.value) * parseInt(inputs.cellSize.value);
            container.style.width = w + 'px'; container.style.height = h + 'px';
            // Redimensiona todos os 3 canvas
            bgCanvas.width = w; bgCanvas.height = h;
            gridCanvas.width = w; gridCanvas.height = h;
            drawCanvas.width = w; drawCanvas.height = h;
        }
        function resizeMap(clear = false) {
            if (clear && !confirm("Apagar desenho atual?")) return;
            resizeCanvasStruct(); 
            drawGrid();
            drawBackground(); // Redesenha o fundo para se ajustar ao novo tamanho
            if (clear) {
                drawCtx.clearRect(0,0, drawCanvas.width, drawCanvas.height);
                history = []; historyStep = -1; saveHistoryState(); autoSave();
                state.offsetX = 50; state.offsetY = 50; updateViewTransform();
            }
        }
        function drawGrid() {
            const w = gridCanvas.width; const h = gridCanvas.height; const s = parseInt(inputs.cellSize.value);
            gridCtx.clearRect(0, 0, w, h); gridCtx.beginPath();
            gridCtx.strokeStyle = inputs.gridColor.value; gridCtx.lineWidth = inputs.gridWidth.value;
            const p = inputs.gridPattern.value;
            if (p === 'dashed') gridCtx.setLineDash([10, 5]); else if (p === 'dotted') gridCtx.setLineDash([2, 3]); else gridCtx.setLineDash([]);
            for (let x = 0; x <= w; x += s) { gridCtx.moveTo(x, 0); gridCtx.lineTo(x, h); }
            for (let y = 0; y <= h; y += s) { gridCtx.moveTo(0, y); gridCtx.lineTo(w, y); }
            gridCtx.stroke();
        }

        // --- FERRAMENTAS E UNDO ---
        function setTool(toolName) {
            state.tool = toolName; Object.values(btns).forEach(b => { if(b.classList) b.classList.remove('active'); });
            if (btns[toolName]) btns[toolName].classList.add('active');
        }
        function saveHistoryState() {
            historyStep++; if (historyStep < history.length) history.length = historyStep;
            history.push(drawCanvas.toDataURL()); updateButtons();
        }
        function undo() { if (historyStep > 0) { historyStep--; restoreHistoryState(); } }
        function redo() { if (historyStep < history.length - 1) { historyStep++; restoreHistoryState(); } }
        function restoreHistoryState() {
            const img = new Image(); img.src = history[historyStep];
            img.onload = () => {
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                const prev = drawCtx.globalCompositeOperation; drawCtx.globalCompositeOperation = 'source-over';
                drawCtx.drawImage(img, 0, 0); drawCtx.globalCompositeOperation = prev;
                updateButtons(); autoSave();
            };
        }
        function updateButtons() { btns.undo.disabled = (historyStep <= 0); btns.redo.disabled = (historyStep >= history.length - 1); }
    </script>
</body>
</html>