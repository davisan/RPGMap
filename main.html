<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Criador de Mapas RPG - Touch</title>
    <style>
        * { box-sizing: border-box; }
        
        /* CORRE√á√ÉO 1: Layout travado nas bordas para evitar que o menu corte */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%; /* Usa 100% em vez de vh para mobile */
            overflow: hidden; /* Impede scroll na p√°gina inteira */
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            /* Previne sele√ß√£o de texto acidental ao tocar */
            -webkit-user-select: none;
            user-select: none; 
            /* Previne comportamentos de toque nativos do browser */
            touch-action: none; 
        }

        body {
            display: flex;
            position: fixed; /* Trava o app na tela */
            top: 0; left: 0; right: 0; bottom: 0;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 280px;
            background-color: #34495e;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            z-index: 10;
            overflow-y: auto; /* Scroll interno apenas no menu */
            touch-action: pan-y; /* Permite scroll vertical com dedo no menu */
        }

        .sidebar h2 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            text-align: center;
            border-bottom: 2px solid #2ecc71;
            padding-bottom: 10px;
        }

        .control-group {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .control-group h3 {
            margin: 0 0 8px 0;
            font-size: 0.9rem;
            color: #bdc3c7;
            text-transform: uppercase;
        }

        .input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px; /* Mais espa√ßo para toque */
        }

        .input-row label { font-size: 0.85rem; color: #ecf0f1; }

        input[type="number"], select {
            width: 70px;
            padding: 6px; /* Touch target maior */
            border-radius: 3px;
            border: none;
            background: #ecf0f1;
        }

        input[type="range"] { width: 100%; height: 20px; } /* Slider mais f√°cil de pegar */
        
        input[type="color"] {
            border: none;
            width: 100%;
            height: 35px; /* Cor mais f√°cil de clicar */
            padding: 0;
            background: none;
        }

        button {
            width: 100%;
            padding: 12px; /* Bot√µes maiores para dedo */
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        button:active { filter: brightness(0.9); transform: scale(0.98); }
        
        .file-btn { background-color: #8e44ad; }
        .save-img-btn { background-color: #2980b9; }
        .reset-btn { background-color: #c0392b; }

        .tools-row { display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap; }
        
        .tool-btn {
            background-color: #7f8c8d;
            flex: 1;
            padding: 15px 5px; /* Bot√µes de ferramenta bem grandes */
        }

        .tool-btn.active {
            background-color: #3498db;
            border: 2px solid #2980b9;
        }

        .action-buttons { display: flex; gap: 5px; margin-top: 5px; }
        .action-buttons button { background-color: #f39c12; }
        .action-buttons button:disabled { background-color: #7f8c8d; opacity: 0.6; }

        /* --- VIEWPORT --- */
        .viewport {
            flex-grow: 1;
            background-color: #95a5a6;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Scroll manual via JS (Pan Tool) */
            position: relative;
            touch-action: none; /* Importante: Bloqueia zoom/scroll nativo do browser na √°rea de desenho */
        }

        #map-container {
            position: relative;
            background-color: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            flex-shrink: 0;
            /* A transforma√ß√£o ser√° usada para o scroll/pan */
            transform-origin: 0 0; 
        }

        canvas { position: absolute; top: 0; left: 0; }
        #gridLayer { z-index: 1; pointer-events: none; }
        #drawLayer { z-index: 2; }

    </style>
</head>
<body>

    <aside class="sidebar">
        <h2>üó∫Ô∏è RPG Map Maker</h2>
        
        <div class="control-group">
            <h3>Arquivo</h3>
            <div style="display: flex; gap: 5px;">
                <button class="file-btn" onclick="saveProjectFile()">üíæ Salvar</button>
                <button class="file-btn" onclick="document.getElementById('fileInput').click()">üìÇ Abrir</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadProjectFile(this)">
            </div>
            <button class="save-img-btn" onclick="exportImage()">üì∑ Baixar Imagem</button>
        </div>

        <div class="control-group">
            <h3>Configurar</h3>
            <div class="input-row"><label>Largura</label><input type="number" id="mapCols" value="20" min="5" max="100"></div>
            <div class="input-row"><label>Altura</label><input type="number" id="mapRows" value="15" min="5" max="100"></div>
            <div class="input-row"><label>C√©lula</label><input type="number" id="cellSize" value="40" min="10" max="100"></div>
            <button class="reset-btn" onclick="resizeMap(true)">Novo Mapa</button>
        </div>

        <div class="control-group">
            <h3>Grade</h3>
            <div class="input-row"><label>Cor</label><div style="width: 60px;"><input type="color" id="gridColor" value="#cccccc" oninput="updateGrid()"></div></div>
            <div class="input-row" style="flex-direction: column; align-items: flex-start;">
                <label>Espessura</label><input type="range" id="gridWidth" min="1" max="5" value="1" oninput="updateGrid()">
            </div>
            <div class="input-row">
                <label>Estilo</label>
                <select id="gridPattern" onchange="updateGrid()">
                    <option value="solid">S√≥lido</option>
                    <option value="dashed">Tracejado</option>
                    <option value="dotted">Pontilhado</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <h3>Ferramentas</h3>
            <div class="tools-row">
                <button id="btnPan" class="tool-btn" onclick="setTool('pan')">üñê Mover</button>
                <button id="btnBrush" class="tool-btn" onclick="setTool('brush')">üñåÔ∏è Pincel</button>
                <button id="btnEraser" class="tool-btn" onclick="setTool('eraser')">üßΩ Borracha</button>
            </div>

            <div class="input-row"><label>Cor Pincel</label><div style="width: 60px;"><input type="color" id="brushColor" value="#2c3e50"></div></div>
            <div class="input-row" style="flex-direction: column; align-items: flex-start;">
                <label>Tamanho</label><input type="range" id="brushSize" min="1" max="50" value="5">
            </div>
            
            <div class="action-buttons">
                <button onclick="undo()" id="btnUndo" title="Undo">‚Ü∂ Undo</button>
                <button onclick="redo()" id="btnRedo" title="Redo">‚Ü∑ Redo</button>
            </div>
        </div>
    </aside>

    <main class="viewport" id="mainViewport">
        <div id="content-wrapper" style="position: absolute; top: 0; left: 0;">
            <div id="map-container">
                <canvas id="gridLayer"></canvas>
                <canvas id="drawLayer"></canvas>
            </div>
        </div>
    </main>

    <script>
        // --- CONFIGURA√á√ÉO ---
        const LOCAL_STORAGE_KEY = 'rpgMapData_touch_v1';
        const viewport = document.getElementById('mainViewport');
        const contentWrapper = document.getElementById('content-wrapper'); // Novo wrapper para Pan suave
        const container = document.getElementById('map-container');
        const gridCanvas = document.getElementById('gridLayer');
        const drawCanvas = document.getElementById('drawLayer');
        const gridCtx = gridCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        
        const inputs = {
            cols: document.getElementById('mapCols'),
            rows: document.getElementById('mapRows'),
            cellSize: document.getElementById('cellSize'),
            gridColor: document.getElementById('gridColor'),
            gridWidth: document.getElementById('gridWidth'),
            gridPattern: document.getElementById('gridPattern'),
            brushColor: document.getElementById('brushColor'),
            brushSize: document.getElementById('brushSize')
        };

        const btns = {
            pan: document.getElementById('btnPan'),
            brush: document.getElementById('btnBrush'),
            eraser: document.getElementById('btnEraser'),
            undo: document.getElementById('btnUndo'),
            redo: document.getElementById('btnRedo')
        };

        // --- ESTADO ---
        let state = {
            isActionActive: false,
            tool: 'pan',
            lastX: 0, lastY: 0,       // Para desenho
            
            // Para Pan (Movimento)
            panStartX: 0, panStartY: 0, 
            offsetX: 50, offsetY: 50  // Posi√ß√£o inicial do mapa na tela
        };

        let history = [];
        let historyStep = -1;

        // --- INICIALIZA√á√ÉO ---
        window.onload = () => {
            if (!loadFromLocalStorage()) {
                resizeMap(true);
            } else {
                updateViewTransform(); // Aplica posi√ß√£o se carregou
            }
            setTool('pan');
        };

        // --- CORE: L√ìGICA DE INPUT UNIFICADA (TOUCH + MOUSE) ---
        
        // 1. Fun√ß√£o para pegar coordenadas X/Y independentemente se √© Dedo ou Mouse
        function getPointerPos(e) {
            // Se for evento de toque
            if(e.touches && e.touches.length > 0) {
                const rect = drawCanvas.getBoundingClientRect();
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top,
                    rawX: e.touches[0].clientX,
                    rawY: e.touches[0].clientY
                };
            }
            // Se for mouse
            else {
                const rect = drawCanvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    rawX: e.clientX,
                    rawY: e.clientY
                };
            }
        }

        // 2. In√≠cio da A√ß√£o (MouseDown / TouchStart)
        function handleStart(e) {
            // Impede scroll da p√°gina e comportamentos nativos
            if (e.cancelable) e.preventDefault();
            
            state.isActionActive = true;
            const pos = getPointerPos(e);

            if (state.tool === 'pan') {
                state.panStartX = pos.rawX - state.offsetX;
                state.panStartY = pos.rawY - state.offsetY;
                viewport.style.cursor = 'grabbing';
            } else {
                // Ferramenta de desenho
                state.lastX = pos.x;
                state.lastY = pos.y;
                performDraw(pos.x, pos.y); // Desenha ponto inicial
            }
        }

        // 3. Movimento (MouseMove / TouchMove)
        function handleMove(e) {
            if (!state.isActionActive) return;
            if (e.cancelable) e.preventDefault();

            const pos = getPointerPos(e);

            if (state.tool === 'pan') {
                // Atualiza offset do mapa
                state.offsetX = pos.rawX - state.panStartX;
                state.offsetY = pos.rawY - state.panStartY;
                updateViewTransform();
            } else {
                // Desenha linha
                performDraw(pos.x, pos.y);
            }
        }

        // 4. Fim da A√ß√£o (MouseUp / TouchEnd)
        function handleEnd(e) {
            if (state.isActionActive) {
                state.isActionActive = false;
                
                if (state.tool === 'pan') {
                    viewport.style.cursor = 'grab';
                } else {
                    // Se estava desenhando, salva hist√≥rico e storage
                    saveHistoryState();
                    autoSave(); 
                }
            }
        }

        // Adiciona Listeners para Mouse E Touch na √°rea do Viewport
        // Usamos { passive: false } para garantir que preventDefault funcione no mobile
        viewport.addEventListener('mousedown', handleStart);
        viewport.addEventListener('touchstart', handleStart, { passive: false });

        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, { passive: false });

        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        // --- DESENHO E PAN ---

        function updateViewTransform() {
            // Move a div que cont√©m os canvas
            contentWrapper.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px)`;
        }

        function performDraw(currX, currY) {
            drawCtx.beginPath();
            drawCtx.moveTo(state.lastX, state.lastY);
            drawCtx.lineTo(currX, currY);
            
            drawCtx.lineWidth = inputs.brushSize.value;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';

            if (state.tool === 'brush') {
                drawCtx.globalCompositeOperation = 'source-over';
                drawCtx.strokeStyle = inputs.brushColor.value;
            } else {
                drawCtx.globalCompositeOperation = 'destination-out';
                drawCtx.strokeStyle = "rgba(0,0,0,1)";
            }
            
            drawCtx.stroke();
            [state.lastX, state.lastY] = [currX, currY];
        }

        // --- ARQUIVOS E PERSIST√äNCIA (Mesmo c√≥digo anterior) ---
        function autoSave() {
            const data = {
                cols: inputs.cols.value, rows: inputs.rows.value, cellSize: inputs.cellSize.value,
                gridColor: inputs.gridColor.value, gridWidth: inputs.gridWidth.value, gridPattern: inputs.gridPattern.value,
                image: drawCanvas.toDataURL()
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!saved) return false;
            try {
                const data = JSON.parse(saved);
                applyMapData(data);
                return true;
            } catch (e) { return false; }
        }

        function saveProjectFile() {
            const data = {
                cols: inputs.cols.value, rows: inputs.rows.value, cellSize: inputs.cellSize.value,
                gridColor: inputs.gridColor.value, gridWidth: inputs.gridWidth.value, gridPattern: inputs.gridPattern.value,
                image: drawCanvas.toDataURL()
            };
            const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = "mapa-rpg.json"; a.click();
            URL.revokeObjectURL(url);
        }

        function loadProjectFile(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    applyMapData(data);
                    autoSave();
                } catch (err) { alert("Erro ao ler arquivo."); }
            };
            reader.readAsText(file);
            input.value = '';
        }

        function applyMapData(data) {
            inputs.cols.value = data.cols; inputs.rows.value = data.rows; inputs.cellSize.value = data.cellSize;
            inputs.gridColor.value = data.gridColor || '#cccccc'; inputs.gridWidth.value = data.gridWidth || 1;
            inputs.gridPattern.value = data.gridPattern || 'solid';
            resizeCanvasStruct();
            drawGrid();
            if (data.image) {
                const img = new Image();
                img.src = data.image;
                img.onload = () => {
                    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                    drawCtx.drawImage(img, 0, 0);
                    history = [drawCanvas.toDataURL()];
                    historyStep = 0;
                    updateButtons();
                };
            }
        }

        function exportImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = drawCanvas.width; tempCanvas.height = drawCanvas.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = "#ffffff"; tCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
            tCtx.drawImage(gridCanvas, 0, 0); tCtx.drawImage(drawCanvas, 0, 0);
            const link = document.createElement('a'); link.download = 'mapa-rpg.png'; link.href = tempCanvas.toDataURL(); link.click();
        }

        // --- MAPA UTILS ---
        function updateGrid() { drawGrid(); autoSave(); }
        
        function resizeCanvasStruct() {
            const w = parseInt(inputs.cols.value) * parseInt(inputs.cellSize.value);
            const h = parseInt(inputs.rows.value) * parseInt(inputs.cellSize.value);
            container.style.width = w + 'px'; container.style.height = h + 'px';
            gridCanvas.width = w; gridCanvas.height = h;
            drawCanvas.width = w; drawCanvas.height = h;
        }

        function resizeMap(clear = false) {
            if (clear && !confirm("Apagar desenho atual?")) return;
            resizeCanvasStruct(); drawGrid();
            if (clear) {
                drawCtx.clearRect(0,0, drawCanvas.width, drawCanvas.height);
                history = []; historyStep = -1; saveHistoryState(); autoSave();
                // Reseta Pan para o centro
                state.offsetX = 50; state.offsetY = 50; updateViewTransform();
            }
        }

        function drawGrid() {
            const w = gridCanvas.width; const h = gridCanvas.height; const s = parseInt(inputs.cellSize.value);
            gridCtx.clearRect(0, 0, w, h); gridCtx.beginPath();
            gridCtx.strokeStyle = inputs.gridColor.value; gridCtx.lineWidth = inputs.gridWidth.value;
            const p = inputs.gridPattern.value;
            if (p === 'dashed') gridCtx.setLineDash([10, 5]); else if (p === 'dotted') gridCtx.setLineDash([2, 3]); else gridCtx.setLineDash([]);
            for (let x = 0; x <= w; x += s) { gridCtx.moveTo(x, 0); gridCtx.lineTo(x, h); }
            for (let y = 0; y <= h; y += s) { gridCtx.moveTo(0, y); gridCtx.lineTo(w, y); }
            gridCtx.stroke();
        }

        // --- FERRAMENTAS E UNDO ---
        function setTool(toolName) {
            state.tool = toolName;
            Object.values(btns).forEach(b => { if(b.classList) b.classList.remove('active'); });
            if (btns[toolName]) btns[toolName].classList.add('active');
        }

        function saveHistoryState() {
            historyStep++;
            if (historyStep < history.length) history.length = historyStep;
            history.push(drawCanvas.toDataURL());
            updateButtons();
        }

        function undo() { if (historyStep > 0) { historyStep--; restoreHistoryState(); } }
        function redo() { if (historyStep < history.length - 1) { historyStep++; restoreHistoryState(); } }

        function restoreHistoryState() {
            const img = new Image(); img.src = history[historyStep];
            img.onload = () => {
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                const prev = drawCtx.globalCompositeOperation;
                drawCtx.globalCompositeOperation = 'source-over';
                drawCtx.drawImage(img, 0, 0);
                drawCtx.globalCompositeOperation = prev;
                updateButtons(); autoSave();
            };
        }
        function updateButtons() { btns.undo.disabled = (historyStep <= 0); btns.redo.disabled = (historyStep >= history.length - 1); }

    </script>
</body>
</html>