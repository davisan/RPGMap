<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPG Map Maker - Cursor Preview</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        * { box-sizing: border-box; }
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; -webkit-user-select: none; user-select: none; touch-action: none; 
        }
        body { display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; }

        /* --- BOT√ÉO MENU --- */
        #toggleBtn {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            width: 44px; height: 44px;
            background-color: #34495e; border: 2px solid #2ecc71; color: #2ecc71;
            border-radius: 8px; font-size: 1.5rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 300px; 
            background-color: #34495e; 
            display: flex; flex-direction: column;
            padding: 10px; padding-top: 65px;
            gap: 8px; 
            box-shadow: 2px 0 5px rgba(0,0,0,0.3); z-index: 10;
            overflow-y: auto; touch-action: pan-y;
            transition: transform 0.3s ease;
        }
        .sidebar.closed { transform: translateX(-100%); }

        details { background: rgba(0,0,0,0.2); border-radius: 6px; overflow: hidden; }
        summary {
            padding: 12px; font-weight: bold; cursor: pointer;
            background-color: rgba(255,255,255,0.05); list-style: none;
            display: flex; justify-content: space-between; align-items: center;
            text-transform: uppercase; font-size: 0.85rem; color: #bdc3c7;
        }
        summary::after { content: '+'; font-size: 1.2rem; font-weight: bold; }
        details[open] summary::after { content: '-'; }
        details[open] summary { border-bottom: 1px solid rgba(255,255,255,0.1); color: #2ecc71; }
        .group-content { padding: 10px; display: flex; flex-direction: column; gap: 8px; }

        .row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
        .row-input { display: flex; justify-content: space-between; align-items: center; }

        label { font-size: 0.85rem; color: #ecf0f1; }
        
        input[type="number"], select { width: 70px; padding: 8px; border-radius: 4px; border: none; background: #ecf0f1; text-align: center;}
        input[type="text"] { width: 100%; padding: 10px; border-radius: 4px; border: none; background: #ecf0f1; }
        input[type="range"] { flex-grow: 1; height: 30px; margin-left: 10px; cursor: pointer; }
        input[type="color"] { border: none; width: 100%; height: 35px; padding: 0; background: none; cursor: pointer; border-radius: 4px;}

        button {
            width: 100%; padding: 12px; border: none; border-radius: 6px; 
            font-weight: bold; font-size: 0.9rem; cursor: pointer; color: white; transition: filter 0.2s;
        }
        button:active { filter: brightness(0.8); transform: translateY(1px); }

        .btn-green { background-color: #27ae60; }
        .btn-blue { background-color: #2980b9; }
        .btn-purple { background-color: #8e44ad; }
        .btn-orange { background-color: #d35400; }
        .btn-red { background-color: #c0392b; }
        .btn-gray { background-color: #7f8c8d; }
        .btn-teal { background-color: #16a085; }
        
        .tool-btn { background-color: #7f8c8d; padding: 15px 5px; font-size: 1.2rem; }
        .tool-btn.active { background-color: #3498db; border: 2px solid #2980b9; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }

        /* --- VIEWPORT --- */
        .viewport {
            flex-grow: 1; background-color: #95a5a6; display: flex;
            justify-content: center; align-items: center; overflow: hidden;
            position: relative; width: 100%;
        }
        #content-wrapper { position: absolute; top: 0; left: 0; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #map-container { position: relative; background-color: white; flex-shrink: 0; overflow: hidden; }

        #videoContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }
        #ytFrame { width: 100%; height: 100%; border: none; display: none; }
        #localVideo { width: 100%; height: 100%; object-fit: cover; display: none; }

        /* --- CAMADAS CANVAS --- */
        canvas { position: absolute; top: 0; left: 0; }
        
        #bgLayer   { z-index: 1; pointer-events: none; }
        #drawLayer { z-index: 2; }
        #gridLayer { z-index: 3; pointer-events: none; }
        /* NOVA CAMADA DE CURSOR */
        #cursorLayer { z-index: 4; pointer-events: none; } /* No topo e transparente a cliques */

    </style>
</head>
<body>

    <button id="toggleBtn" onclick="toggleSidebar()">‚ò∞</button>

    <aside class="sidebar" id="sidebar">
        
        <details open>
            <summary>Ferramentas</summary>
            <div class="group-content">
                <div class="row-3">
                    <button id="btnPan" class="tool-btn" onclick="setTool('pan')">üñê</button>
                    <button id="btnBrush" class="tool-btn" onclick="setTool('brush')">üñåÔ∏è</button>
                    <button id="btnEraser" class="tool-btn" onclick="setTool('eraser')">üßΩ</button>
                </div>
                <div class="row-input">
                    <div style="width: 50px;"><input type="color" id="brushColor" value="#2c3e50"></div>
                    <input type="range" id="brushSize" min="1" max="500" value="5">
                </div>
                <div class="row-2">
                    <button onclick="undo()" id="btnUndo" class="btn-orange">‚Ü∂ Undo</button>
                    <button onclick="redo()" id="btnRedo" class="btn-orange">‚Ü∑ Redo</button>
                </div>
            </div>
        </details>

        <details>
            <summary>Configura√ß√£o Grade</summary>
            <div class="group-content">
                <div class="row-input">
                    <label>L x A</label>
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="mapCols" value="20">
                        <input type="number" id="mapRows" value="15">
                    </div>
                </div>
                <div class="row-input">
                    <label>C√©lula</label>
                    <input type="number" id="cellSize" value="40">
                </div>
                <button class="btn-green" onclick="resizeMap()">Aplicar Tamanho</button>
                
                <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 5px 0;"></div>

                <div class="row-input">
                    <label>Cor / Tipo</label>
                    <div style="width: 40px;"><input type="color" id="gridColor" value="#cccccc" oninput="updateGrid()"></div>
                    <select id="gridPattern" onchange="updateGrid()" style="flex-grow:1; margin-left:5px;">
                        <option value="solid">S√≥lido</option>
                        <option value="dashed">Tra√ßo</option>
                        <option value="dotted">Ponto</option>
                    </select>
                </div>
                <div class="row-input">
                    <label>Espessura</label>
                    <input type="range" id="gridWidth" min="1" max="5" value="1" oninput="updateGrid()">
                </div>
                <div class="row-input">
                    <label>Deslocar X/Y</label>
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="gridOffsetX" value="0" oninput="updateGrid()" title="Offset Horizontal">
                        <input type="number" id="gridOffsetY" value="0" oninput="updateGrid()" title="Offset Vertical">
                    </div>
                </div>
            </div>
        </details>

        <details>
            <summary>Fundo & M√≠dia</summary>
            <div class="group-content">
                <label>Imagem Est√°tica</label>
                <div class="row-input">
                    <button class="btn-orange" onclick="document.getElementById('bgInput').click()">üñºÔ∏è Carregar</button>
                    <button class="btn-gray" onclick="clearBackground()" style="width: 50px; margin-left: 5px;">‚ùå</button>
                </div>
                <input type="file" id="bgInput" accept="image/*" style="display: none;" onchange="loadBackground(this)">

                <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 5px 0;"></div>

                <label>V√≠deo Local (PC)</label>
                <div class="row-input">
                    <button class="btn-teal" onclick="document.getElementById('videoInput').click()">üìÇ V√≠deo</button>
                    <button class="btn-gray" onclick="clearVideo()" style="width: 50px; margin-left: 5px;">‚ùå</button>
                </div>
                <input type="file" id="videoInput" accept="video/*" style="display: none;" onchange="loadLocalVideo(this)">

                <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 5px 0;"></div>

                <label>YouTube Link</label>
                <input type="text" id="ytUrl" placeholder="Cole o link aqui...">
                <button class="btn-red" onclick="setYoutubeBackground()">‚ñ∂Ô∏è Aplicar YT</button>
            </div>
        </details>

        <details>
            <summary>Arquivo</summary>
            <div class="group-content">
                <div class="row-2">
                    <button class="btn-purple" onclick="saveProjectFile()">üíæ Salvar</button>
                    <button class="btn-purple" onclick="document.getElementById('fileInput').click()">üìÇ Abrir</button>
                </div>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadProjectFile(this)">
                <button class="btn-blue" onclick="exportImage()">üì∑ Baixar PNG</button>
                <button class="btn-red" onclick="resizeMap(true)">üóëÔ∏è Novo Mapa</button>
            </div>
        </details>

    </aside>

    <main class="viewport" id="mainViewport">
        <div id="content-wrapper">
            <div id="map-container">
                <div id="videoContainer">
                    <iframe id="ytFrame" allow="autoplay; encrypted-media" allowfullscreen></iframe>
                    <video id="localVideo" loop muted playsinline></video>
                </div>
                <canvas id="bgLayer"></canvas>
                <canvas id="drawLayer"></canvas>
                <canvas id="gridLayer"></canvas>
                <canvas id="cursorLayer"></canvas>
            </div>
        </div>
    </main>

    <script>
        const LOCAL_STORAGE_KEY = 'rpgMapData_v10_cursor';
        
        // --- ELEMENTOS ---
        const sidebar = document.getElementById('sidebar');
        const viewport = document.getElementById('mainViewport');
        const contentWrapper = document.getElementById('content-wrapper');
        const container = document.getElementById('map-container');
        const ytFrame = document.getElementById('ytFrame');
        const localVideo = document.getElementById('localVideo');
        
        const bgCanvas = document.getElementById('bgLayer');
        const gridCanvas = document.getElementById('gridLayer');
        const drawCanvas = document.getElementById('drawLayer');
        // NOVO: Refer√™ncia ao canvas do cursor
        const cursorCanvas = document.getElementById('cursorLayer');

        const bgCtx = bgCanvas.getContext('2d');
        const gridCtx = gridCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        // NOVO: Contexto do cursor
        const cursorCtx = cursorCanvas.getContext('2d');
        
        // --- INPUTS ---
        const inputs = {
            cols: document.getElementById('mapCols'), 
            rows: document.getElementById('mapRows'), 
            cellSize: document.getElementById('cellSize'),
            gridColor: document.getElementById('gridColor'),
            gridWidth: document.getElementById('gridWidth'),
            gridPattern: document.getElementById('gridPattern'),
            gridOffsetX: document.getElementById('gridOffsetX'),
            gridOffsetY: document.getElementById('gridOffsetY'),
            brushColor: document.getElementById('brushColor'), 
            brushSize: document.getElementById('brushSize'),
            ytUrl: document.getElementById('ytUrl')
        };
        
        const btns = {
            pan: document.getElementById('btnPan'), 
            brush: document.getElementById('btnBrush'), 
            eraser: document.getElementById('btnEraser'),
            undo: document.getElementById('btnUndo'), 
            redo: document.getElementById('btnRedo')
        };

        // --- ESTADO ---
        let state = {
            isActionActive: false, tool: 'pan',
            lastX: 0, lastY: 0, panStartX: 0, panStartY: 0, offsetX: 50, offsetY: 50,
            bgImageSrc: null, youtubeID: null, hasLocalVideo: false
        };
        let history = []; let historyStep = -1;

        // --- INIT ---
        window.onload = () => {
            if (!loadFromLocalStorage()) { resizeMap(true); } else { updateViewTransform(); }
            setTool('pan');
        };

        function toggleSidebar() { sidebar.classList.toggle('closed'); }

        // --- NOVA FUN√á√ÉO: DESENHAR PREVIS√ÉO DO CURSOR ---
        function updateCursorPreview(pos) {
            // Limpa o canvas do cursor
            cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);

            // S√≥ mostra se n√£o estiver a mover
            if (state.tool === 'pan') return;

            const size = parseInt(inputs.brushSize.value);
            const radius = size / 2;

            cursorCtx.beginPath();
            cursorCtx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            
            // Estilo dependendo da ferramenta
            if (state.tool === 'eraser') {
                cursorCtx.fillStyle = "rgba(231, 76, 60, 0.3)"; // Vermelho transparente
                cursorCtx.strokeStyle = "#e74c3c";
            } else {
                cursorCtx.fillStyle = "rgba(46, 204, 113, 0.3)"; // Verde transparente (ou podia usar a cor do pincel)
                cursorCtx.strokeStyle = "#2ecc71";
            }
            cursorCtx.lineWidth = 1;
            cursorCtx.fill();
            cursorCtx.stroke();
        }

        // --- INPUT HANDLING (MODIFICADO PARA HOVER) ---
        function getPointerPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            // Verifica se √© toque ou mouse
            const clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
            const clientY = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;

            // Se n√£o houver input (ex: touchend), retorna null
            if (clientX === undefined || clientY === undefined) return null;

            return { x: clientX - rect.left, y: clientY - rect.top, rawX: clientX, rawY: clientY };
        }

        // Handler para movimento sem clique (Hover)
        function handleHoverMove(e) {
            // Se estivermos a arrastar (pan), n√£o queremos ver o cursor de desenho
            if (state.isActionActive && state.tool === 'pan') return;

            const pos = getPointerPos(e);
            if(pos) updateCursorPreview(pos);
        }

        // Limpa o cursor quando o rato sai da √°rea
        function handleMouseLeave() {
             cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
        }


        function handleStart(e) {
            if (e.target.closest('#toggleBtn')) return; 
            // Permite intera√ß√£o com elementos de form na sidebar
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'SUMMARY') return;

            if (e.cancelable) e.preventDefault();
            state.isActionActive = true; const pos = getPointerPos(e);
            if (!pos) return;

            if (state.tool === 'pan') {
                state.panStartX = pos.rawX - state.offsetX; state.panStartY = pos.rawY - state.offsetY; viewport.style.cursor = 'grabbing';
                cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height); // Limpa cursor ao mover
            } else { 
                state.lastX = pos.x; state.lastY = pos.y; performDraw(pos.x, pos.y);
                updateCursorPreview(pos); // Atualiza cursor ao clicar
            }
        }
        function handleMove(e) {
            if (!state.isActionActive) return; if (e.cancelable) e.preventDefault(); const pos = getPointerPos(e);
            if (!pos) return;

            if (state.tool === 'pan') { state.offsetX = pos.rawX - state.panStartX; state.offsetY = pos.rawY - state.panStartY; updateViewTransform(); } 
            else { 
                performDraw(pos.x, pos.y);
                updateCursorPreview(pos); // Cursor segue o arrasto
            }
        }
        function handleEnd() {
            if (state.isActionActive) {
                state.isActionActive = false;
                if (state.tool === 'pan') { viewport.style.cursor = 'grab'; } else { saveHistoryState(); autoSave(); }
            }
        }
        
        // Listeners para A√ß√µes (Clique/Toque)
        viewport.addEventListener('mousedown', handleStart); viewport.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('mousemove', handleMove); window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('mouseup', handleEnd); window.addEventListener('touchend', handleEnd);

        // NOVO: Listeners para Hover (apenas mouse, touch n√£o tem hover)
        viewport.addEventListener('mousemove', handleHoverMove);
        viewport.addEventListener('mouseleave', handleMouseLeave);

        function updateViewTransform() { contentWrapper.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px)`; }
        function performDraw(currX, currY) {
            drawCtx.beginPath(); drawCtx.moveTo(state.lastX, state.lastY); drawCtx.lineTo(currX, currY);
            drawCtx.lineWidth = inputs.brushSize.value; drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
            if (state.tool === 'brush') { drawCtx.globalCompositeOperation = 'source-over'; drawCtx.strokeStyle = inputs.brushColor.value; } 
            else { drawCtx.globalCompositeOperation = 'destination-out'; drawCtx.strokeStyle = "rgba(0,0,0,1)"; }
            drawCtx.stroke(); [state.lastX, state.lastY] = [currX, currY];
        }

        // --- GRID ---
        function drawGrid() {
            const w = gridCanvas.width; const h = gridCanvas.height; const s = parseInt(inputs.cellSize.value);
            const offX = parseInt(inputs.gridOffsetX.value) || 0; const offY = parseInt(inputs.gridOffsetY.value) || 0;
            gridCtx.clearRect(0, 0, w, h); gridCtx.beginPath();
            gridCtx.strokeStyle = inputs.gridColor.value; gridCtx.lineWidth = inputs.gridWidth.value;
            const p = inputs.gridPattern.value;
            if (p === 'dashed') gridCtx.setLineDash([10, 5]); else if (p === 'dotted') gridCtx.setLineDash([2, 3]); else gridCtx.setLineDash([]); 
            const startX = (offX % s) - s; const startY = (offY % s) - s;
            for (let x = startX; x <= w; x += s) { gridCtx.moveTo(x + 0.5, 0); gridCtx.lineTo(x + 0.5, h); }
            for (let y = startY; y <= h; y += s) { gridCtx.moveTo(0, y + 0.5); gridCtx.lineTo(w, y + 0.5); }
            gridCtx.stroke();
        }
        function updateGrid() { drawGrid(); autoSave(); }

        // --- V√çDEO & FUNDO ---
        function extractVideoID(url) { const m = url.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/); return (m && m[2].length === 11) ? m[2] : null; }
        function setYoutubeBackground() { const id = extractVideoID(inputs.ytUrl.value); if(id){state.youtubeID=id; state.hasLocalVideo=false; renderVideoState(); autoSave();}else{alert("Link inv√°lido.");} }
        function loadLocalVideo(i) { const f=i.files[0]; if(!f)return; localVideo.src=URL.createObjectURL(f); localVideo.play(); state.hasLocalVideo=true; state.youtubeID=null; inputs.ytUrl.value=""; renderVideoState(); }
        function renderVideoState() { ytFrame.style.display='none'; localVideo.style.display='none'; if(state.hasLocalVideo){localVideo.style.display='block';localVideo.play();}else if(state.youtubeID){ytFrame.src=`https://www.youtube.com/embed/${state.youtubeID}?autoplay=1&mute=1&controls=0&loop=1&playlist=${state.youtubeID}&playsinline=1`;ytFrame.style.display='block';}else{ytFrame.src="";localVideo.pause();localVideo.removeAttribute('src');} }
        function clearVideo() { state.youtubeID=null; state.hasLocalVideo=false; inputs.ytUrl.value=''; renderVideoState(); autoSave(); }
        function loadBackground(i) { const f=i.files[0]; if(!f)return; const r=new FileReader(); r.onload=e=>{state.bgImageSrc=e.target.result;drawBackground();autoSave();}; r.readAsDataURL(f); i.value=''; }
        function drawBackground() { bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height); if(!state.bgImageSrc)return; const i=new Image(); i.src=state.bgImageSrc; i.onload=()=>{bgCtx.drawImage(i,0,0,bgCanvas.width,bgCanvas.height);}; }
        function clearBackground() { state.bgImageSrc=null; drawBackground(); autoSave(); }

        // --- STORAGE & EXPORT ---
        function getCurrentMapData() { return { cols:inputs.cols.value, rows:inputs.rows.value, cellSize:inputs.cellSize.value, gridColor:inputs.gridColor.value, gridWidth:inputs.gridWidth.value, gridPattern:inputs.gridPattern.value, gridOffsetX:inputs.gridOffsetX.value, gridOffsetY:inputs.gridOffsetY.value, image:drawCanvas.toDataURL(), bgImage:state.bgImageSrc, youtubeID:state.youtubeID }; }
        function autoSave() { localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(getCurrentMapData())); }
        function saveProjectFile() { const d=getCurrentMapData(); const b=new Blob([JSON.stringify(d)],{type:"application/json"}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download="mapa.json"; a.click(); URL.revokeObjectURL(u); }
        function loadFromLocalStorage() { const s=localStorage.getItem(LOCAL_STORAGE_KEY); if(!s)return false; try{applyMapData(JSON.parse(s));return true;}catch(e){return false;} }
        function loadProjectFile(i) { const f=i.files[0]; if(!f)return; const r=new FileReader(); r.onload=e=>{try{applyMapData(JSON.parse(e.target.result));autoSave();}catch(err){alert("Erro ao ler arquivo.");}}; r.readAsText(f); i.value=''; }
        function applyMapData(d) { inputs.cols.value=d.cols; inputs.rows.value=d.rows; inputs.cellSize.value=d.cellSize; inputs.gridColor.value=d.gridColor||'#cccccc'; inputs.gridWidth.value=d.gridWidth||1; inputs.gridPattern.value=d.gridPattern||'solid'; inputs.gridOffsetX.value=d.gridOffsetX||0; inputs.gridOffsetY.value=d.gridOffsetY||0; state.bgImageSrc=d.bgImage||null; state.youtubeID=d.youtubeID||null; if(state.youtubeID)inputs.ytUrl.value=`https://youtube.com/watch?v=${state.youtubeID}`; resizeCanvasStruct(); drawGrid(); drawBackground(); renderVideoState(); if(d.image){const i=new Image(); i.src=d.image; i.onload=()=>{drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); drawCtx.drawImage(i,0,0); history=[drawCanvas.toDataURL()]; historyStep=0; updateButtons();};} }
        function exportImage() { const t=document.createElement('canvas'); t.width=drawCanvas.width; t.height=drawCanvas.height; const tc=t.getContext('2d'); tc.fillStyle="#ffffff"; tc.fillRect(0,0,t.width,t.height); if(state.bgImageSrc)tc.drawImage(bgCanvas,0,0); tc.drawImage(drawCanvas,0,0); tc.drawImage(gridCanvas,0,0); const l=document.createElement('a'); l.download='mapa-rpg.png'; l.href=t.toDataURL(); l.click(); }

        // --- UTILS ---
        function resizeCanvasStruct() { const w=parseInt(inputs.cols.value)*parseInt(inputs.cellSize.value); const h=parseInt(inputs.rows.value)*parseInt(inputs.cellSize.value); container.style.width=w+'px'; container.style.height=h+'px'; bgCanvas.width=w; bgCanvas.height=h; gridCanvas.width=w; gridCanvas.height=h; drawCanvas.width=w; drawCanvas.height=h; cursorCanvas.width=w; cursorCanvas.height=h; }
        function resizeMap(c=false) { if(c&&!confirm("Apagar tudo?"))return; resizeCanvasStruct(); drawGrid(); drawBackground(); renderVideoState(); if(c){drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); history=[]; historyStep=-1; saveHistoryState(); autoSave(); state.offsetX=50; state.offsetY=50; updateViewTransform(); clearBackground(); clearVideo(); cursorCtx.clearRect(0,0,cursorCanvas.width,cursorCanvas.height);} }
        function setTool(t) { state.tool=t; Object.values(btns).forEach(b=>{if(b.classList)b.classList.remove('active');}); if(btns[t])btns[t].classList.add('active'); }
        function saveHistoryState() { historyStep++; if(historyStep<history.length)history.length=historyStep; history.push(drawCanvas.toDataURL()); updateButtons(); }
        function undo() { if(historyStep>0){historyStep--; restoreHistoryState();} }
        function redo() { if(historyStep<history.length-1){historyStep++; restoreHistoryState();} }
        function restoreHistoryState() { const i=new Image(); i.src=history[historyStep]; i.onload=()=>{drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height); const p=drawCtx.globalCompositeOperation; drawCtx.globalCompositeOperation='source-over'; drawCtx.drawImage(i,0,0); drawCtx.globalCompositeOperation=p; updateButtons(); autoSave();}; }
        function updateButtons() { btns.undo.disabled=(historyStep<=0); btns.redo.disabled=(historyStep>=history.length-1); }
    </script>
</body>
</html>